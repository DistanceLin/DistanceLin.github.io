<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Distancelin&#39;s blog</title>
  <subtitle>Distancelin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-29T14:44:54.117Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>distancelin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DCL的简单分析</title>
    <link href="http://yoursite.com/2017/10/20/DCL%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/10/20/DCL的简单分析/</id>
    <published>2017-10-20T14:42:31.000Z</published>
    <updated>2017-10-29T14:44:54.117Z</updated>
    
    <content type="html"><![CDATA[<p>DCL是单例模式的懒汉式实现方式之一，全称为Double Check Lock，和饿汉式单例实现相比，它的单例对象实例化是在第一次调用获取单例的时候。与饿汉式单例模式一样，它也是线程安全的。很重要的一点就是关键字volatile的使用，下面从为什么volatile可以保证DCL的线程安全进行学习总结。<br><a id="more"></a></p>
<h2 id="DCL中第二次判空的作用"><a href="#DCL中第二次判空的作用" class="headerlink" title="DCL中第二次判空的作用"></a>DCL中第二次判空的作用</h2><p>不使用volatile的DCL代码如下：</p>
<pre><code>public class SingleTon {
    public static SingleTon mInstance;
    //构造方法私有化
    private SingleTon() {

    }

    public static SingleTon getInstance() {
        if (mInstance == null) {
            synchronized (SingleTon.class) {
                if (mInstance == null) {
                    mInstance = new SingleTon();
                }
            }
        }
        return mInstance;
    }
}
</code></pre><ul>
<li>第一次判空是为了避免不必要的同步，不用每次调用getInstance(）都进行同步。</li>
<li>第二次判空是为了在实例为空的时候创建对象</li>
</ul>
<p><strong>第二次判空必不可少，若在去掉第二层判空的情况下出现以下情况：</strong></p>
<ol>
<li>线程1执行完第一层判断之后，得到mInstance为空，cpu调度到线程2</li>
<li>线程2执行第一层判断，mInstance也为空，并执行同步块，完成了mInstance的实例化，此时mInstance已经不为空</li>
<li>cpu调度到线程1，从上次线程1中断的地方继续执行(第一层判空之后)，注意此在时线程1中判断的mInstance仍然为空，线程1继续执行实例化操作</li>
</ol>
<p>这样mInstance被重复初始化了两次，而且两次的mInstance不是同一个实例。所以应该在同步块里进行第二层判空。</p>
<h2 id="不使用volatile为什么会不安全？"><a href="#不使用volatile为什么会不安全？" class="headerlink" title="不使用volatile为什么会不安全？"></a>不使用volatile为什么会不安全？</h2><p>java中为引用赋值可以理解为三个步骤：</p>
<pre><code>mInstance=new SingleTon();
</code></pre><ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将内存空间的地址赋值给对应的引用</li>
</ol>
<p>由于jvm的指令重排序，2、3两个步骤可能颠倒，若2、3被重排序，那么考虑如下情况：</p>
<ol>
<li>线程1进行第一次判断为空，进入同步块，进行第二次判断，也为空，开始创建对象并赋值给mInstacne.</li>
<li>JVM在堆上为对象分配空间</li>
<li>将对象的内存地址赋值给mInstance，那么此时mInstance已不等于null了</li>
<li>此时线程2执行了第一次判断(因为第一次判断不在syn块中，所以可以执行)，得到mInstance不为空，然后直接返回了mInstance，但此时mInstance所引用的对象还没有初始化，线程2直接使用的时候就会出现异常。</li>
</ol>
<p>上述问题的原因是线程2拿到了单例对象的引用，但是对象却没有被初始化。根本原因是因为指令重排序问题，假如禁止了指令重排序，保证对象的初始化在引用赋值之前，那么只要线程2判断mInstance不为空，那么单例对象肯定已经完成了初始化。</p>
<p>禁止JVM指令重排序就可以采用volatile关键字，底层通过内存屏障实现。只需把mInstance声明为volatile类型。</p>
<pre><code>public class SingleTon {
    public static volatile SingleTon mInstance;
    //构造方法私有化
    private SingleTon() {

    }

    public static SingleTon getInstance() {
        if (mInstance == null) {
            synchronized (SingleTon.class) {
                if (mInstance == null) {
                    mInstance = new SingleTon();
                }
            }
        }
        return mInstance;
    }
}
</code></pre><h2 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h2><p>因为静态内部类不会在外部类加载的时候被加载，而是在第一次调用getInstance()的时候才加载，这种方式既实现了懒汉式单例，又线程安全,关键是非常简洁：  </p>
<pre><code>public class SingleTon {
    private SingleTon() {

    }

    public static SingleTon getInstance() {
        return SingletonHolder.mInstance;
    }
    static class SingletonHolder{
        static final SingleTon mInstance=new SingleTon();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DCL是单例模式的懒汉式实现方式之一，全称为Double Check Lock，和饿汉式单例实现相比，它的单例对象实例化是在第一次调用获取单例的时候。与饿汉式单例模式一样，它也是线程安全的。很重要的一点就是关键字volatile的使用，下面从为什么volatile可以保证DCL的线程安全进行学习总结。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>隐式intent的匹配规则</title>
    <link href="http://yoursite.com/2017/07/26/%E9%9A%90%E5%BC%8Fintent%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2017/07/26/隐式intent的匹配规则/</id>
    <published>2017-07-26T13:08:47.000Z</published>
    <updated>2017-07-26T13:11:15.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>通过隐式intent启动组件的时候，系统通过将该intent的内容与其他应用的AndroidManifest.xml中声明的Intent-filter进行比较，找到匹配的组件，并将该intent传递给组件，若有多个组件匹配，那么会提示用户选取某个应用。通过隐式intent来启动activity的匹配过程如下如所示：<br><a id="more"></a><br><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-24/14689291.jpg" alt=""><br>最终调用到了所匹配成功的Activity的onCreate()方法。<br>隐式intent的匹配涉及了Intent中的三个信息，分别是：</p>
<ol>
<li>Action</li>
<li>Category</li>
<li>Data</li>
</ol>
<p>这三个信息都可以在AndroidManifest文件中进行声明，典型的例子如下：</p>
<pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>一个隐式intent的匹配就是根据Intent-filter中设置的这三个信息来找到对应的组件。下面分别是这三个信息的匹配过程。</p>
<h3 id="1-action的匹配"><a href="#1-action的匹配" class="headerlink" title="1.action的匹配"></a>1.action的匹配</h3><p>在声明一个intent对象的时候，可以通过构造方法来指定该intent对象的action属性，也可以通过setAction()方法来设置。action属性是String类型。系统中内置了许多action，这些action对应了Intent类中的一系列常量。比如Intent.ACTION_SEND常用于分享。<br>隐式intent必须指定action属性。这一属性对应于Intent-filter中的</p>
<pre><code>&lt;action android:name=“”/&gt;
</code></pre><p>action属性为String类型，只有当隐式intent的action与Intent-filter中的某一个action<strong>完全一致</strong>的时候（Intent-filter中的action标签可以有多个），action才算匹配成功。  </p>
<h3 id="2-category的匹配"><a href="#2-category的匹配" class="headerlink" title="2.category的匹配"></a>2.category的匹配</h3><p>通过addCategory()方法指定，同action标签一样，category标签在Intent-filter中也可以有多个，但是几乎所有的Intent-filter必须包含以下category标签（有一类特殊的category标签除外）：</p>
<pre><code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
</code></pre><blockquote>
<p> startActivity() 和 startActivityForResult() 将按照已申明 CATEGORY_DEFAULT 类别的方式处理所有 Intent。 如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为你的 Activity。</p>
</blockquote>
<p>在声明隐式intent用于启动activity时可以不调用addCategory（)来指定category，因为startActivity() 和 startActivityForResult()默认使用DEFAULT这个category。但是必须指定action。</p>
<h3 id="3-data的匹配"><a href="#3-data的匹配" class="headerlink" title="3.data的匹配"></a>3.data的匹配</h3><p>data由两个部分组成：</p>
<ul>
<li>mimeType</li>
<li>URI</li>
</ul>
<p>在Intent-filter中由data标签指定，格式如下：</p>
<pre><code>&lt;data  android:scheme=&quot;string&quot;
        android:host=&quot;string&quot;
        android:port=&quot;string&quot;
        android:path=&quot;string&quot;
        android:pathPattern=&quot;string&quot;
        android:pathPrefix=&quot;string&quot;
        android:mimeType=&quot;string&quot;/&gt;
</code></pre><p>最后一项指定mimeType，前几项合起来指定了URI，URI的标准格式为：<br>\<scheme>://\<host>:\<port>/[\<path></path>|\<pathprefix>|\<pathpattern>]，比如：<br>file://abc<br><a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a><br>可以通过以下三个方法来设置intent的Uri和mimeType：</pathpattern></pathprefix></port></host></scheme></p>
<ul>
<li>setData(Uri data)</li>
<li>setType(String type)</li>
<li>setDataAndType(Uri data,String type)</li>
</ul>
<p>setData()——设置intent的Uri，目标activity可以通过getIntent().getData()来获取传递的Uri。<br>setTyoe()——设置intent的mimeType。<br>setDataAndType()——同时设置Uri和mimeType。<br><strong>setData()和setType()会互相清除对方的值，所以要同时设置Uri和mimeType必须使用setDataAndType()</strong> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>若隐式intent里同时设置了action、category、data，则这三者必须完全和intent-filter里声明的匹配规则相同才能匹配成功。反过来说，如果一个intent-filter里声明了action、category和data，那么要想和该intent-filter匹配，对应的intent里也必须设置这几项，<strong>缺一不可</strong>。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>通过隐式intent分享特定内容：</p>
<pre><code>Intent intent=new Intent(Intent.ACTION_SEND);
intent.putExtra(Intent.EXTRA_TEXT,&quot;I&apos;m shared content&quot;);
intent.setType(&quot;text/plain&quot;);
//始终弹出选择界面，避免用户选择默认应用
Intent chooser=Intent.createChooser(intent,&quot;请选择应用&quot;)
if(intent.resolveActivity(getPackageManager())!=null){
        startActivity(chooser);
}
</code></pre><p><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-25/95676358.jpg" alt=""><br>调用浏览器浏览特定网页：</p>
<pre><code>Intent intent=new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));
if(intent.resolveActivity(getPackageManager())!=null){
         startActivity(intent);
}
</code></pre><p><strong>intent里的data和extra都可以携带数据，在使用隐式intent启动activity的时候，有的activity接收extra携带\<key,value>格式的数据(如上例一)，有的接收data携带的Uri形式的数据(如上例二)。</key,value></strong></p>
<h2 id="deep-link从网页启动App"><a href="#deep-link从网页启动App" class="headerlink" title="deep link从网页启动App"></a>deep link从网页启动App</h2><p>除了从原生app中构建隐式intent来启动其他应用的组件之外，还可以从网页中启动原生app，实现的原理也基于intent-filter。下面是一个测试：<br>在原生app的某个activity里，声明了如下的intent-filter：</p>
<pre><code>&lt;activity android:name=&quot;.Main2Activity&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
         &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
         &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
         &lt;!--这一行意味着满足wei://www.distancelin.cn*格式的链接都可以调启该组件--&gt;
         &lt;data
             android:host=&quot;www.distancelin.cn&quot;
             android:scheme=&quot;wei&quot;/&gt;
     &lt;/intent-filter&gt;
 &lt;/activity&gt;
</code></pre><p>然后在简书上用markdown写下了这样一篇文章，文章只包含了一个链接:<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-26/24779686.jpg" alt=""><br>测试文章发布之后，将该文章分享到qq，然后在qq里点击文章中的链接，就会发现调启了app中对应的activity，并且可以在activity里获取到通过链接传来的参数：</p>
<pre><code>Intent intent=getIntent();
Uri uri=intent.getData();
String site=uri.getQueryParameter(&quot;site&quot;);
Log.i(&quot;H&quot;,site);
</code></pre><p><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-26/32396193.jpg" alt=""><br>如果没安装该app，是不会有任何提示的，具体提示用户下载安装app的逻辑还需要进一步实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;隐式Intent&quot;&gt;&lt;a href=&quot;#隐式Intent&quot; class=&quot;headerlink&quot; title=&quot;隐式Intent&quot;&gt;&lt;/a&gt;隐式Intent&lt;/h2&gt;&lt;p&gt;通过隐式intent启动组件的时候，系统通过将该intent的内容与其他应用的AndroidManifest.xml中声明的Intent-filter进行比较，找到匹配的组件，并将该intent传递给组件，若有多个组件匹配，那么会提示用户选取某个应用。通过隐式intent来启动activity的匹配过程如下如所示：&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>新的征程——随手记</title>
    <link href="http://yoursite.com/2017/07/16/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B%E2%80%94%E2%80%94%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/07/16/新的征程——随手记/</id>
    <published>2017-07-16T14:35:04.000Z</published>
    <updated>2017-07-16T15:52:34.746Z</updated>
    
    <content type="html"><![CDATA[<p>有一段时间没有更博了，前段时间的主要事情：</p>
<ol>
<li>7月3日晚，完成了整个大学生涯的最后一门考试——《软件工程》</li>
<li>远行之前回家里和亲人们简单地团聚</li>
<li>7月10日，坐了一天两夜的火车，从重庆来到了深圳</li>
</ol>
<p>这篇博客不记录任何技术上的知识，全是我离开大学这座象牙塔，离家几千里生活三天之后的所见所感。<br><a id="more"></a></p>
<h2 id="关于校园"><a href="#关于校园" class="headerlink" title="关于校园"></a>关于校园</h2><p>至今我都很不情愿去接受我为期接近二十年的校园生涯就这样即将结束，即使大四下学期还会回到大学中去为整个校园生活画上一个句号——毕业设计。仔细想来，离开了学校这个地方，我们几乎没有任何机会能够每天这样规律、集体地坐在一个固定的地方去学习新的东西。上小学的时候，盼着能像初中生一样，可以每个星期在学校住；上初中的时候，盼着能像高中生一样，能够拥有自己的手机；上高中的时候，盼着能像大学生一样，可以那么自由，想逃课就逃课，考试不用削尖脑袋去考高分，及格就好；而身在大学里，又思考着快点毕业，去大城市闯荡。然而现在的我身在大城市，除了对今后的生活充满着激情和期待之外，我更怀念我的读书生涯。</p>
<h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>孤身来到深圳，一切对我来说都相当陌生，如果非要说哪一点让我感到亲切的话，那应该是这里的路还有这里的天气，深圳的路平坦又宽阔，这一点和成都很相似；而这里的天气，太阳始终很毒，和重庆非常类似。在这座既陌生却带有熟悉气息的城市里，我拿着并不算高的实习工资，一切都必须精打细算，在这边许多东西都要重新买，伞、拖鞋、洗漱用品、被子。。。当面对着银行卡里并不多的预算和有限的工资，我真实地感觉到，生活，可能真的不是那么容易。以前在学校里，家里都会把足够的钱按时打到我的卡上，虽然算不上多，但是在衣食住行之后，也总有结余，而即将一个人在这边度过半年之久的我，真的应该好好地为他们想想。<br>在这里的前两天，心里也是五味杂陈，由于刚到这边，路还不熟悉，手机也关机了不能导航，一路问加一路找才回到了住处，这两天里，一个人上下班，一个人逛超市，晚上回到家里也是空荡荡的(其他邻居还没入住)，可能人在这种环境下都会不自然地想家吧，开始感觉到亲人和家，才是永远最好的地方。现在想起来，在我很小的时候，爸爸每年就会出省打工，这样算下来，他已经像这样在外面呆了有十多年了，很难想象刚开始的那几年他是怎么熬过来的。<br>不过此时此刻我也渐渐地习惯了如今一个人的生活，可能是邻居们都入住了吧哈哈，仔细想想，我在外面把自己照顾好，过得开开心心的，不也是家里人希望看到的吗？我能做的就是努力工作，经常给他们报报平安说说话。</p>
<h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>尽管才入职两天，但是我已经感受到，这样的工作就是我想要的工作，不拘束的工作环境，平易近人的同事，热心指导新人的前辈们这些都让我感觉在这里工作挺亲切，虽然作为实习生，我还有相当多的东西需要学习。但是我相信在这几个月的实习中，我能够学到在学校里永远学习不到的东西，做技术，当然是技术上的提升才是最有成就感的。在这里给自己定一个小目标，在正式工作的时候，争取开发水平上升一个档次。当然最终要生活还是得谈到工资，那这里暂时把工资目标定位12k。加油！！！</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然是要贴几张图啦，这是骑车图中拍的即将下雨之前的深圳天空：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-16/18785371.jpg" alt=""><br>接下来是我即将实习几个月的地方——深圳市随手科技有限公司：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-7-16/25715930.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一段时间没有更博了，前段时间的主要事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;7月3日晚，完成了整个大学生涯的最后一门考试——《软件工程》&lt;/li&gt;
&lt;li&gt;远行之前回家里和亲人们简单地团聚&lt;/li&gt;
&lt;li&gt;7月10日，坐了一天两夜的火车，从重庆来到了深圳&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这篇博客不记录任何技术上的知识，全是我离开大学这座象牙塔，离家几千里生活三天之后的所见所感。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Android中的Context</title>
    <link href="http://yoursite.com/2017/06/24/%E6%B5%85%E8%B0%88Android%E4%B8%AD%E7%9A%84Context/"/>
    <id>http://yoursite.com/2017/06/24/浅谈Android中的Context/</id>
    <published>2017-06-24T08:02:30.000Z</published>
    <updated>2017-07-16T14:33:56.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方对Context的解释"><a href="#官方对Context的解释" class="headerlink" title="官方对Context的解释"></a>官方对Context的解释</h2><p>这是Context类的声明和继承关系：<br><img src="https://ooo.0o0.ooo/2017/06/24/594e20a73559f.png" alt=""><br>可以看到Context是一个抽象类，在它的众多子类中，可以发现Activity、Service和Application的影子：<br><a href="https://developer.android.google.cn/reference/android/content/Context.html" target="_blank" rel="external">谷歌api文档</a><br><a id="more"></a><br>官方对Context类的解释如下：  </p>
<blockquote>
<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p>
</blockquote>
<p>从上面的解释可以概括出，Context代表了应用的运行环境(上下文)，本身为抽象类，由安卓系统内部实现，通过Context对象我们可以访问某些资源和类，除此之外还可以用Context对象来启动一个activity，发送广播等。</p>
<h2 id="更通俗的理解"><a href="#更通俗的理解" class="headerlink" title="更通俗的理解"></a>更通俗的理解</h2><p>每个应用都运行在特定的上下文环境中，而Context类允许我们对应用的运行状态进行访问。正是因为有了Context，我们才可以在Activity中访问一些资源文件、图片、主题和样式以及系统的文件目录。除此之外，我们还可以通过Context来获取安卓系统内置的一些服务，比如访问网络状态等系统服务。<br><strong>由于Activity、Service和Application都继承自Context，所以一个应用中的context对象数量为三者的实例数量相加</strong></p>
<h2 id="Context的使用场景"><a href="#Context的使用场景" class="headerlink" title="Context的使用场景"></a>Context的使用场景</h2><h3 id="1-显式启动组件"><a href="#1-显式启动组件" class="headerlink" title="1.显式启动组件"></a>1.显式启动组件</h3><p>最常见的就是通过利用context来启动另一个Activity：</p>
<pre><code>Intent intent = new Intent(context, MyActivity.class);
startActivity(intent);
</code></pre><p>这里显式启动一个活动需要两个信息：</p>
<ol>
<li>应用的包名，它标识了该组件所在的应用</li>
<li>将要启动的目标组件的类权限定名<br>其中，信息1在可以在传入的context上调用context.getPackageName()来获得；第二个信息通过传入的class对象的getClassName()来获得。</li>
</ol>
<h3 id="2-动态创建view"><a href="#2-动态创建view" class="headerlink" title="2.动态创建view"></a>2.动态创建view</h3><p>在代码里创建一个view的时候也需要传入一个context对象，比如：</p>
<pre><code>ImageView imageView=new ImageView(context);
</code></pre><p>这里传入的context包含了如下的上下文环境：</p>
<ol>
<li>用于将dp,sp单位转化为pixels的屏幕尺寸信息</li>
<li>组件对应的style样式</li>
</ol>
<h3 id="3-加载布局文件"><a href="#3-加载布局文件" class="headerlink" title="3.加载布局文件"></a>3.加载布局文件</h3><p>将xml布局文件加载到内存：</p>
<pre><code>LayoutInflater inflater = LayoutInflater.from(context);
inflater.inflate(R.layout.my_layout, parent);
</code></pre><p>这里context主要用于加载xml文件的时候根据布局来创建view。</p>
<h3 id="4-获取系统内置服务"><a href="#4-获取系统内置服务" class="headerlink" title="4.获取系统内置服务"></a>4.获取系统内置服务</h3><p>比如设备当前的网络服务，进而判断网络状态：</p>
<pre><code>ConnectivityManager connectivityManager= (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
</code></pre><p>再如获取系统内置的Notification服务用于通知栏提示：</p>
<pre><code>// Context objects are able to fetch or start system services.

NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

int notificationId = 1;

// Context is required to construct RemoteViews
Notification.Builder builder =new Notification.Builder(context).setContentTitle(&quot;custom title&quot;);
notificationManager.notify(notificationId, builder.build());
</code></pre><p><a href="https://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String" target="_blank" rel="external">查看所有系统内置服务点我</a>)</p>
<h2 id="Application-Context和Activity-Context"><a href="#Application-Context和Activity-Context" class="headerlink" title="Application Context和Activity Context"></a>Application Context和Activity Context</h2><p>因为activity、service和application都继承自context类，所以在大多数情况下，当我们的某些方法需要以context作为参数的时候，在activity中我们都可以简单地传入this就可以了，但是activity中还提供了getApplicationContext()方法来获得application对应的context，这两种context是有区别的，在有的情况下就只能使用activity对应的context，具体的使用情景如下表：<br><img src="https://ooo.0o0.ooo/2017/06/27/59515239457fc.png" alt=""><br><strong>与UI相关的context都最好使用activity对应的context，除此之外，application对应的context也可以用于启动一个activity，但是由于application与activity相比，没有所对应的任务栈(所有的activity都运行在对应的任务栈中)，所以用application context来启动activity的时候需要指定新的任务栈，这样就增加了任务栈的数量，不便管理，所以最好只用activity context来启动另一个活动</strong></p>
<h2 id="context引起的内存泄露"><a href="#context引起的内存泄露" class="headerlink" title="context引起的内存泄露"></a>context引起的内存泄露</h2><p>由于context经常作为形参传入到其他方法中，如果对context使用不当导致在context本来应该被回收的时候（比如activity被销毁）仍然被持有，就会使得该context不能被回收，最终导致内存泄露。<br>下面是两种比较明显的activity内存泄露情况：</p>
<h3 id="1-静态成员持有context对象"><a href="#1-静态成员持有context对象" class="headerlink" title="1.静态成员持有context对象"></a>1.静态成员持有context对象</h3><pre><code>Public Class MyActivity extends AppCompactActivity{
    static Textview mTextView;
    @override
    protect void onCreate(Bundle onSavedInstanceState){
        mTextView = new TextView(this);
    }
}
</code></pre><p>由于mTextView是一个静态成员变量(类变量)并且它持有当前activity的引用，所以一旦当该activity生命周期结束本该被回收的时候，由于静态变量的声明周期大于对象的声明周期，所以在该activity即将被回收的时候，mTextView不会被置为Null，而是会始终应用该activity，而activity将由于一直被引用而无法被GC回收，最终导致内存泄露。<br>若声明为非静态变量，那么mTextView就会在activity被回收的时候被置为Null，而activity一旦不被任何引用持有，它就可以被标记为可回收对象，最终由GC回收。</p>
<h3 id="2-单例模式导致的context内存泄露"><a href="#2-单例模式导致的context内存泄露" class="headerlink" title="2.单例模式导致的context内存泄露"></a>2.单例模式导致的context内存泄露</h3><p>若某个单例对象包含context引用，而该context又不是application对应的context的话，就会导致contetx内存泄露，代码如下：</p>
<pre><code>Public Class Singleton{
    Private Context mContext;

    Public Static Singleton getInstance(Context context){
        //这里将引发内存泄露
        this.mContext=context;
        return Holder.instance;
    }
    Static Class Holder{
        Private Static Singleton instance = new Singleton();
    }
}
</code></pre><p>首先需要明白，在android中，单例对象的最大特点之一是其生命周期和application保持一致，为什么？<br>我是这样理解的：<br>试想一下，假如我GC现在想回收上面的单例对象，但是发现该对象被静态变量所引用，如果不是静态变量的话就可以在这时把这个引用置为Null，但是很明显，这里的Singleton是静态变量，始终不会被置为Null，而该单例对象又包含了context引用，那么当该context本该被回收的时候，会由于一直被单例对象持有而导致无法被回收，最终同样导致内存泄露。<br><strong>解决方法也很直观，那就是直接传入application context，因为application context的生命周期和应用一致，进而也就和单例对象一致，就不会面临本该被回收而不能被回收的局面</strong><br>将上面的注释下的代码修改如下：</p>
<pre><code>this.mContext=context.getApplicationContext();
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>牢记一句话，UI相关用Activity context，单例模式用application context</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;官方对Context的解释&quot;&gt;&lt;a href=&quot;#官方对Context的解释&quot; class=&quot;headerlink&quot; title=&quot;官方对Context的解释&quot;&gt;&lt;/a&gt;官方对Context的解释&lt;/h2&gt;&lt;p&gt;这是Context类的声明和继承关系：&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/24/594e20a73559f.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到Context是一个抽象类，在它的众多子类中，可以发现Activity、Service和Application的影子：&lt;br&gt;&lt;a href=&quot;https://developer.android.google.cn/reference/android/content/Context.html&quot;&gt;谷歌api文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>邮件服务基本知识</title>
    <link href="http://yoursite.com/2017/06/17/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/06/17/邮件服务基本知识/</id>
    <published>2017-06-17T07:43:45.000Z</published>
    <updated>2017-06-17T08:42:40.360Z</updated>
    
    <content type="html"><![CDATA[<p>无意之间在廖雪峰的官网上看到了python的教程，简单浏览了一段，小有收获，对python有了浅显的认识，同时也收获到一些计算机的基础知识，简单做个记录，主要关于邮件服务的协议。</p>
<h2 id="邮件收发的过程"><a href="#邮件收发的过程" class="headerlink" title="邮件收发的过程"></a>邮件收发的过程</h2><a id="more"></a>
<p>首先涉及的几个名词：</p>
<ul>
<li>MUA:mail user agent,邮件用户代理，指我们平时使用的电子邮件软件，比如网易邮箱大师和foxmail等。</li>
<li>MTA:mail transfer agent,邮件传输代理，指的是email邮件服务提供商，如网易163、新浪和qq邮箱等等。</li>
<li>MDA:mail delivery agent,邮件投递代理。</li>
</ul>
<p>这是廖雪峰官网中对邮件收发过程的描述：<br>假如我现在用我的163邮箱coder_jason@163.com给我的qq邮箱1627642910@qq.com发一封邮件，我首先在网易邮箱大师（此时它就是MUA）里面编辑好了我的邮件，然后写上目标邮箱。点击发送之后的过程如下：</p>
<ol>
<li>因为我的邮件发自网易邮箱，所以邮件首先会到达网易的MTA。</li>
<li>网易的MTA收到我的邮件之后会转发到qq邮箱的MTA</li>
<li>qq邮箱的MTA再把邮件投放到MDA，邮件到达MDA之后，就会保存在qq邮箱的某个服务器上，当我们在未来的某时间登陆qq邮箱的时候，就可以收到新邮件提醒</li>
<li>最后再通过MUA将邮件从qq的MDA上取下来，邮件就保存到了本地</li>
</ol>
<p>这个过程如下：  </p>
<blockquote>
<p>发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人</p>
</blockquote>
<p>那么如果要自行编写一个客户端来收发邮件，实际上就包括了以下两个操作：</p>
<ol>
<li>编写MUA，将邮件发送到MTA</li>
<li>编写MUA，从MDA上获取邮件</li>
</ol>
<h2 id="邮件服务相关协议"><a href="#邮件服务相关协议" class="headerlink" title="邮件服务相关协议"></a>邮件服务相关协议</h2><ul>
<li><p>SMTP(发邮件时)：Simple Mail Transfer Protocol，将邮件从MUA发送到MTA时采用smtp协议，MTA到另一个MTA也是用SMTP协议。</p>
</li>
<li><p>POP(收邮件时)：Post Office Protocol，目前版本是3，俗称POP3，MUA从MDA上获取邮件时可采用pop协议</p>
</li>
<li>IMAP(收邮件时)：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。</li>
</ul>
<p>邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。</p>
<p>类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。、</p>
<h2 id="使用python来发送邮件"><a href="#使用python来发送邮件" class="headerlink" title="使用python来发送邮件"></a>使用python来发送邮件</h2><p>这里使用python让我的网易邮箱给qq邮箱发一封邮件：  </p>
<pre><code>from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr
//导入模块
import smtplib
//header编码，防止中文乱码
def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))

from_addr = input(&apos;From: &apos;)
password = input(&apos;Password: &apos;)
to_addr = input(&apos;To: &apos;)
smtp_server = input(&apos;SMTP server: &apos;)

msg = MIMEText(&apos;我是测试邮件&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
msg[&apos;From&apos;] = _format_addr(&apos;distancelin &lt;%s&gt;&apos; % from_addr)
msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)
msg[&apos;Subject&apos;] = Header(&apos;来自SMTP的问候……&apos;, &apos;utf-8&apos;).encode()
//smtp默认端口号为25
server = smtplib.SMTP(smtp_server, 25)
//显示调试信息
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()
</code></pre><p>登陆qq邮箱显示成功接收到邮件：<br><img src="https://ooo.0o0.ooo/2017/06/17/5944eaed40e9a.png" alt=""><br><strong>这里能使用python来控制coder_jason@163.com发送邮件的前提是在网易邮箱里开启SMTP服务</strong><br><img src="https://ooo.0o0.ooo/2017/06/17/5944eaf72c159.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意之间在廖雪峰的官网上看到了python的教程，简单浏览了一段，小有收获，对python有了浅显的认识，同时也收获到一些计算机的基础知识，简单做个记录，主要关于邮件服务的协议。&lt;/p&gt;
&lt;h2 id=&quot;邮件收发的过程&quot;&gt;&lt;a href=&quot;#邮件收发的过程&quot; class=&quot;headerlink&quot; title=&quot;邮件收发的过程&quot;&gt;&lt;/a&gt;邮件收发的过程&lt;/h2&gt;
    
    </summary>
    
      <category term="计算机基础、python" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E3%80%81python/"/>
    
    
      <category term="邮件" scheme="http://yoursite.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://yoursite.com/2017/06/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/06/14/设计模式之适配器模式/</id>
    <published>2017-06-14T13:28:26.000Z</published>
    <updated>2017-06-16T08:14:06.752Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客最后修改于6/16/2017 4:14:04 PM<br>最近学习《android源码设计模式》的同时，越来越感受到了设计模式在android源码中体现在相当多的地方，而且现今github上比较流行的开源库中也大都运用到了设计模式，这里先简单记录一下适配器模式的基本思想和例子，下一篇文章中会跟随android源码设计模式来梳理一下listview以及recyclerview中适配器模式的运用。</p>
<h2 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h2><a id="more"></a>
<p>适配器在生活中算是很常见了，就拿笔记本的电源适配器来说，它的作用是把220v的电压转化为5v的电压，因为笔记本的电源接口大多是5v的，这就出现了不兼容的情况，而适配器就起到了一个中间层的作用，将不兼容的220v电压转化为了笔记本兼容的5v电压。使得我们可以使用哪个220v电压来给笔记本充电，也就是220v电压和笔记本一起工作。<br>简而言之，适配器模式，就是通过一个中间层(adapter)来将不兼容的接口转化为另一种接口，使得原本不兼容的两个类能够在一起协同工作。通过上述例子来对应，那就是，电源适配器(adapter)将220v的电压转化为5v电压，使得220v电压和笔记本协同工作。<br>适配器模式的包括以下三个部分：<br>adaptee： 需要被转化(适配)的类，如上面的220v电压<br>adapter： 中间层适配器，起转化作用，如上面的电源适配器<br>target： 转化之后的结果，如上面的5v电压<br>adapter、adaptee应该声明为Class，而target通常对应了一个Interface。</p>
<h2 id="适配器模式的分类"><a href="#适配器模式的分类" class="headerlink" title="适配器模式的分类"></a>适配器模式的分类</h2><p>适配器模式分为以下两类：</p>
<ul>
<li>类适配器</li>
<li>对象适配器</li>
</ul>
<p>其中类适配器通过继承的方式实现，而对象适配器通过组合的方式来实现。对象适配器比类适配器更加灵活，使用场景也更丰富。<br>下面分别是采用类适配器和对象适配器来实现笔记本电源适配器的例子：  </p>
<h3 id="1-类适配器实现"><a href="#1-类适配器实现" class="headerlink" title="1.类适配器实现"></a>1.类适配器实现</h3><p>类适配器模式反映到java代码上最典型的特点就是继承，首先写出adaptee，也就是220v电压的充电，</p>
<pre><code>class V220 {
    public int get220() {
        return 220;
    }
}
</code></pre><p>接下来是target对应的interface，5v：</p>
<pre><code>interface V5{
    void get5();
}
</code></pre><p>最后是核心adapter，<strong>类适配器的核心是，adapter继承adaptee并实现target</strong>，按照这个规则，写出的adapter如下：</p>
<pre><code>class Adapter extends V220 implements V5{
    @Override
    public int get5() {
        int temp=get220();
        //将220v的电压转化为5v电压，这只是个模拟操作
        return temp/44
        }
}
</code></pre><p>下面是测试用例：  </p>
<pre><code>public class Computer {
    public static void main(String[] args) {
        Adapter adapter=new Adapter();
        //充电5V
        adapter.get5();
    }
}
</code></pre><h3 id="2-对象适配器实现"><a href="#2-对象适配器实现" class="headerlink" title="2.对象适配器实现"></a>2.对象适配器实现</h3><p>对象适配器采用组合的方式来实现，<strong>核心是adapter包含了一个adaptee并实现了target</strong>，对应的代码如下：</p>
<pre><code>class Adapter1 implements V5{
    V220 mV220;

    public Adapter1(V220 mV220) {
        this.mV220 = mV220;
    }

    @Override
    public void get5() {
        int temp=mV220.get220();
        //将220v的电压转化为5v电压，这只是个模拟操作
        return temp/44
    }
}
</code></pre><p>可以看到，和类适配器相比，不同之处在于，类适配器通过继承adaptee来获得get220v()方法，而对象适配器通过传入一个adaptee对象并通过组合的方式来获得get220v方法。java只支持单继承，所以这种方式比起类适配器来说更加灵活实用。<br><strong>总而言之，适配器模式当然是用来处理不适配，不兼容的情况，通过适配器来协调不兼容的两者，使得它们可以协同工作</strong></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另一种情况下的适配器：<br>很多情况下，java中的一个interface里往往声明了许多抽象方法，而这个接口又很可能在许多地方都会用到，这时就可以创建一个新的Adapter类来实现该接口，并让所有的方法默认实现为空，在使用时就可以通过继承Adapter的方式来覆盖我们需要的那一部分方法而不用实现所有的抽象方法，在RxJava的观察者中就可以这样实现：  </p>
<pre><code>public class ObserverAdapter&lt;T&gt; implements Observer&lt;T&gt; {
    @Override
    public void onSubscribe(@NonNull Disposable d) {

    }

    @Override
    public void onNext(@NonNull T o) {

    }

    @Override
    public void onError(@NonNull Throwable e) {

    }

    @Override
    public void onComplete() {

    }
}
</code></pre><p>在RxJava的使用就可以这样写：  </p>
<pre><code>call.subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new ObserverAdapter&lt;NewsBean&gt;(){
            @Override
            public void onNext(@NonNull NewsBean o) {
                callback.onBannerNewsFinish(o.getTop_stories());
                callback.onLatestNewsFinish(o.getStories(),o.getDate());
            }
        });
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客最后修改于6/16/2017 4:14:04 PM&lt;br&gt;最近学习《android源码设计模式》的同时，越来越感受到了设计模式在android源码中体现在相当多的地方，而且现今github上比较流行的开源库中也大都运用到了设计模式，这里先简单记录一下适配器模式的基本思想和例子，下一篇文章中会跟随android源码设计模式来梳理一下listview以及recyclerview中适配器模式的运用。&lt;/p&gt;
&lt;h2 id=&quot;什么是适配器模式？&quot;&gt;&lt;a href=&quot;#什么是适配器模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是适配器模式？&quot;&gt;&lt;/a&gt;什么是适配器模式？&lt;/h2&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>修改apk的debug签名</title>
    <link href="http://yoursite.com/2017/05/26/%E4%BF%AE%E6%94%B9apk%E7%9A%84debug%E7%AD%BE%E5%90%8D/"/>
    <id>http://yoursite.com/2017/05/26/修改apk的debug签名/</id>
    <published>2017-05-26T07:13:06.000Z</published>
    <updated>2017-05-26T09:25:49.710Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手的爱课项目由于apk签名的问题导致微信分享和登陆出现错误，其实主要涉及apk的签名问题，查看了官方文档的解释，终于发现上学期学的信息安全知识派上了用场。这里作为一个简单的记录。<br><a href="https://developer.android.com/studio/publish/app-signing.html#release-mode" target="_blank" rel="external">官方文档之-签署你的应用</a><br><a id="more"></a></p>
<h2 id="调试时使用的签名"><a href="#调试时使用的签名" class="headerlink" title="调试时使用的签名"></a>调试时使用的签名</h2><p>使用android studio进行调试的时候，如果没有特别指定应该使用哪一个签名文件的话，android studio将会使用默认的debug.keystore文件来签名apk，在windows系统里，这个文件位于C:\Users\username.android目录下，如下：<br><img src="http://i1.piimg.com/588926/1b7dbf05ef1111f0.png" alt=""><br>在该目录下执行以下命令可以查看keystore中存放着的信息：</p>
<pre><code>keytool -list -v -keystore keystoreName
</code></pre><p><img src="http://i1.piimg.com/588926/03f42dd436120e6b.png" alt=""><br>在进行调试的时候默认采用这些摘要进行apk签名，这里是微信所提供的apk签名获取软件，输入应用的包名就可以获取到apk的签名：<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319167&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信apk签名工具</a>  </p>
<h2 id="发布apk"><a href="#发布apk" class="headerlink" title="发布apk"></a>发布apk</h2><p>在生成apk的时候不应该还使用调试用的签名文件，这时需要先生成签名文件(.jks意味java keystore和.keystore无本质区别)，<br><img src="http://i4.buimg.com/588926/6e0ca6609170b2d1.png" alt=""><br>这样，在以后新版本apk发布的时候，必须使用相同的证书来对apk进行签名，只有这样才能保证apk的覆盖安装，否则必须卸载旧的版本才能安装新版本。</p>
<h2 id="使用正式签名进行调试"><a href="#使用正式签名进行调试" class="headerlink" title="使用正式签名进行调试"></a>使用正式签名进行调试</h2><p>在调试的时候android studio默认使用debug.keystore来进行签名，而release版本需要我们自己新建的签名文件来签名，两种情况下得到的apk签名自然不同，而微信开放平台要求填写apk的签名，如下：<br><img src="http://i1.piimg.com/588926/8573b98c179f8018.png" alt=""><br>因为填写的是apk的release版本签名，这就导致了在调试的时候因为apk签名不同而使得微信提供的功能不能正常使用，所以需要修改调试时的签名，使得和release版本签名一致：<br>open module settings：<br><img src="http://i4.buimg.com/588926/816e59ff8bedb27b.png" alt=""><br>这里设置为前面步骤新生成的.jks文件。<br><img src="http://i4.buimg.com/588926/cee19d5c55b6e908.png" alt=""><br>接下来配置debug和release版本下的对应签名设置，这里都设置为了使用同一个签名文件进行apk签名。<br>最后可以在module下的gradle文件中看到android studio为我们生成了如下的配置：<br><img src="http://i4.buimg.com/588926/081ea37c860ec453.png" alt=""><br>这就完成了在debug版本和release版本的apk具有由相同的签名，调试的时候也不会出现微信签名不符的问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接手的爱课项目由于apk签名的问题导致微信分享和登陆出现错误，其实主要涉及apk的签名问题，查看了官方文档的解释，终于发现上学期学的信息安全知识派上了用场。这里作为一个简单的记录。&lt;br&gt;&lt;a href=&quot;https://developer.android.com/studio/publish/app-signing.html#release-mode&quot;&gt;官方文档之-签署你的应用&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="apk签名" scheme="http://yoursite.com/tags/apk%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android中几个常用文件目录</title>
    <link href="http://yoursite.com/2017/05/21/Android%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2017/05/21/Android中几个常用文件目录/</id>
    <published>2017-05-21T06:50:29.000Z</published>
    <updated>2017-05-21T09:15:44.159Z</updated>
    
    <content type="html"><![CDATA[<p>最近在进行图片下载的时候涉及到了文件的保存目录，安卓里提供了许多获取文件目录的方法，为了便于区别在这里作一个记录。安卓手机提供了内部存储(internal storage)和外部存储(external storage)来保存数据。<br><a id="more"></a></p>
<h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><p>内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下，sharedPreference和sqlite数据库文件都存放在这个内部存储中，用activity的openFileOutput()方法创建的文件也存放在内部存储中。<br>内部存储的目录一般是/data/data/packageName/,不同的手机有一定的差别，下面分别是我的真机和genymotion模拟器的内部存储目录：<br><img src="http://i4.buimg.com/588926/2245551bb328bbf5.png" alt=""></p>
<p><img src="http://i4.buimg.com/588926/8d61fc475f45708d.png" alt=""></p>
<p>这是ddms的fileExploer查看到的内部存储：<br><img src="http://i1.piimg.com/588926/113c941f632dc014.png" alt=""><br>可以看到内部存储按照应用的包名来管理文件，应用智能访问自己包名对应的文件。<br><strong>内部存储的所有数据在应用卸载之后会被删除</strong></p>
<h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><p>外部存储不只是指代sd卡，现在的很多手机不用插入sd卡，但是也存在外部存储，比如我的手机为64G，但是没有提供sd卡的扩展，但是这64G仍然指的是外部存储，  </p>
<blockquote>
<p>所有的安卓设备都有外部存储和内部存储，这两个名称来源于安卓的早期设备，那个时候的设备内部存储确实是固定的，而外部存储确实是可以像U盘一样移动的。但是在后来的设备中，很多中高端机器都将自己的机身存储扩展到了8G以上，他们将存储在概念上分成了”内部internal” 和”外部external” 两部分，但其实都在手机内部。所以不管安卓手机是否有可移动的sdcard，他们总是有外部存储和内部存储。最关键的是，我们都是通过相同的api来访问可移动的sdcard或者手机自带的存储（外部存储）。</p>
</blockquote>
<p>外部存储可以存储应用私有的数据和公有的数据，区别在于在外部存储上的私有数据在应用卸载之后会被删除，而公有数据不会被删除，比如可以将用户下载的文件保存在外部公有文件中，这时在用户卸载应用的时候，文件下载的文件仍然可以保留。而如果缓存数据太多，保存在内部存储中可能会迅速占满内部存储，这时就需要把数据保存在外部存储的私有文件里。</p>
<h3 id="外部存储的私有文件"><a href="#外部存储的私有文件" class="headerlink" title="外部存储的私有文件"></a>外部存储的私有文件</h3><p>可以通过以下方式的到外部存储私有文件的目录：<br><img src="http://i2.muimg.com/588926/3d3b847095aefba2.png" alt=""><br>截图的后半部分是/com.distancelin.zhihudaily/file/pictures<br>拿到这些目录之后就可以通过File类在外部存储创建私有文件了，如下：</p>
<pre><code>File file = new File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES), pictureName);}
</code></pre><p>以上代码在外部存储的picture目录下创建了名为pictureName的私有文件。</p>
<h3 id="外部存储的公有文件"><a href="#外部存储的公有文件" class="headerlink" title="外部存储的公有文件"></a>外部存储的公有文件</h3><p>在外存储上放公共文件可以使用getExternalStoragePublicDirectory()</p>
<pre><code>File file = new File(Environment.getExternalStoragePublicDirectory(
Environment.DIRECTORY_PICTURES), pictureName);
</code></pre><p>在上面的代码中创建获得了存放picture的目录，并且新创建一个pictureName文件。<br><strong>api 版本低于8，那么不能使用getExternalStoragePublicDirectory()，而是使用Environment.getExternalStorageDirectory(),他不带参数，也就不能自己创建一个目录，只是返回外部存储的根路径,这时需要拿到路径之后自己通过File类的方法来建立文件夹</strong>，比如：</p>
<pre><code>  //构建文件夹
String fileStoreDir = Environment.getExternalStorageDirect().getAbsolutePath()+File.separator+&quot;zhihudailyDownload&quot;;
File dir = new File(fileStoreDir);
File file = new File(dir+File.separator+mFilename);
</code></pre><p>以上的代码在外部存储中创建了/zhihudailyDownload/mfilename的文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将内部存储和外部存储的几个方法对应起来：<br><img src="http://i2.muimg.com/588926/453a95e1c0e66329.png" alt=""><br><strong>可以看到对私有数据而言，内部存储保存在/data/，而外部存储保存在Android/data/，而外部公有文件需要我们自己去决定目录</strong></p>
<p>顺便贴一下图片下载成功之后更新图库的方法，其实方法就是发送一个广播让图库应用去扫描添加图片：</p>
<pre><code>   //参数分别为ContentResolver，需要扫描的图片绝对路径，图片的名称，描述符(为null即可)
MediaStore.Images.Media.insertImage(getContentResolver(),file.getAbsolutePath(),mFilename,null);
   //发送广播，将文件解析为URI并设置给intent
sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot;+file.getAbsolutePath())));
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在进行图片下载的时候涉及到了文件的保存目录，安卓里提供了许多获取文件目录的方法，为了便于区别在这里作一个记录。安卓手机提供了内部存储(internal storage)和外部存储(external storage)来保存数据。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>官方文档学习之-高效加载大图</title>
    <link href="http://yoursite.com/2017/05/11/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BD%E5%A4%A7%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/05/11/官方文档学习之-高效加载大图/</id>
    <published>2017-05-11T13:50:01.000Z</published>
    <updated>2017-05-11T14:34:12.626Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客作为是图片加载的开端，为了更好地理解图片加载方面的知识，我参考官方文档进行一些练习，最后再比较综合地结合参考尝试构造一个基本的图片加载框架出来，尽管Glide已经独当一面了，但是图片加载的原理也定会让我收获不小。<br>本文的<a href="https://developer.android.com/topic/performance/graphics/load-bitmap.html" target="_blank" rel="external">google官网链接</a><br><a id="more"></a></p>
<h2 id="不作优化的情况"><a href="#不作优化的情况" class="headerlink" title="不作优化的情况"></a>不作优化的情况</h2><p>在安卓设备上显示图片最简单的方法就是将图片设置给imageview，这里的图片格式可以是png、jpg以及其他常见的格式。<br>手机屏幕是有限的，许多情况下我们可能会在布局文件里设置imageview的宽高(比如100dp)，这时候将一张很大的图片设置给imageview，这种情况imageview加载图片的时候会把图片按照原来的大小整个加载进内存再设置给imageview，而imageview内部负责对图片进行缩放，虽然显示为小图，但是内存占用却是原来大图的大小。</p>
<p>这里用一张大图作为实验(934x623)：<br><img src="http://i1.piimg.com/588926/f7ce46e2392591d8.png" alt=""><br>下面通过指定imageview宽高为100dp来进行显示，代码很简单：</p>
<pre><code>&lt;ImageView
   android:layout_width=&quot;100dp&quot;
   android:layout_height=&quot;100dp&quot;
   android:id=&quot;@+id/image&quot;
   android:layout_below=&quot;@+id/download&quot;/&gt;
</code></pre><p>activity中的关键代码：</p>
<pre><code>imageView.setImageResource(R.drawable.jj);  
</code></pre><p>内存占用如下（26.32MB）：<br><img src="http://i1.piimg.com/588926/0ab1e360ec022402.png" alt=""></p>
<h2 id="高效加载"><a href="#高效加载" class="headerlink" title="高效加载"></a>高效加载</h2><p>官方文档中提到，主要使用BitmapFactory.Options来缩放图片，主要使用到options的inSampleSize字段，它的意思是采样率，失踪应该取大于1的数值，比如inSampleSize=2时，采样后的图片宽高都为原来的1/2，那么图片的像素就变为了原来的1/4，官方推荐最好将inSampleSize总是设置为2的指数，如1、2、4、8…，假如设置为3的话系统可能会选择2来代替。<br>通过采样率来加载图片的步骤：</p>
<ol>
<li>将BitmapFactory.Options的inJustDecodeBounds设置为true并加载图片</li>
<li>从BitmapFactory.Options中取出原始图片宽高</li>
<li>根据采样率的规则以及view所需要的大小计算inSampleSize</li>
<li>将BitmapFactory.Options的inJustDecodeBounds设置为false,再次加载图片</li>
</ol>
<p><strong>inJustDecodeBounds设置为true的目的是在不把图片加载到内存的情况下获取图片的原始大小</strong></p>
<p>根据以上四个步骤对应代码如下：</p>
<pre><code> public static Bitmap decodeSampleBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight){
    final BitmapFactory.Options options=new BitmapFactory.Options();
    // 1 第一次加载
    options.inJustDecodeBounds=true;
    BitmapFactory.decodeResource(res,resId,options);
    //3 计算采样率
    options.inSampleSize=caculateInSampleSize(options,reqWidth,reqHeight);
    //4.根据计算的采样率再次加载
    options.inJustDecodeBounds=false;
    return BitmapFactory.decodeResource(res,resId,options);
}

private static int caculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    //获取图片的原始大小
    int height=options.outHeight;
    int width=options.outWidth;
    //默认为1
    int inSampleSize=1;
    //计算采样率
    if(height&gt;reqHeight||width&gt;reqWidth){
        int halfHeight=height/2;
        int halfWidth=width/2;
        while((halfHeight/inSampleSize)&gt;=reqHeight &amp;&amp; (halfWidth/inSampleSize)&gt;=reqWidth){
            inSampleSize*=2;
        }}
    return inSampleSize;
    }
</code></pre><p>这样就得到了采样之后的图片，现在对应activity中的代码改为了如下：</p>
<pre><code>int width=imageView.getWidth();
int height=imageView.getHeight();
imageView.setImageBitmap(bitmapUtils.decodeSampleBitmapFromResource(getResources(),R.drawable.jj,width,height));
</code></pre><p>内存占用如下(11.34MB)：<br><img src="http://i4.buimg.com/588926/d8263a6e1c9e0142.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客作为是图片加载的开端，为了更好地理解图片加载方面的知识，我参考官方文档进行一些练习，最后再比较综合地结合参考尝试构造一个基本的图片加载框架出来，尽管Glide已经独当一面了，但是图片加载的原理也定会让我收获不小。&lt;br&gt;本文的&lt;a href=&quot;https://developer.android.com/topic/performance/graphics/load-bitmap.html&quot;&gt;google官网链接&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="官方文档学习记录" scheme="http://yoursite.com/categories/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>volley学习之缓存篇</title>
    <link href="http://yoursite.com/2017/05/09/volley%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/05/09/volley学习之缓存的原理/</id>
    <published>2017-05-09T06:20:29.000Z</published>
    <updated>2017-05-12T01:40:47.599Z</updated>
    
    <content type="html"><![CDATA[<p>在前面简单地学习了volley的基本请求过程，那就是先访问缓存，缓存命中且没有过期就直接返回缓存的response，否则就进行网络请求，并对结果进行缓存，接下来再记录一下我对volley缓存部分的学习。</p>
<h2 id="缓存目录的创建"><a href="#缓存目录的创建" class="headerlink" title="缓存目录的创建"></a>缓存目录的创建</h2><a id="more"></a>
<p>缓存文件的创建是在第一次调用Volley.newRequestQueue()的时候,该方法中有如下代码：</p>
<pre><code>//DEFAULT_CACHE_DIR默认值为“volley”
File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);
....
//创建DiskBasedCache缓存
RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
queue.start();
</code></pre><p>所以，volley是采用名为DiskBasedCache的类来实现缓存功能。<br>跟踪来到DiskBasedCache的构造方法：</p>
<pre><code>public DiskBasedCache(File rootDirectory) {
    this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);
}
</code></pre><p>DEFAULT_DISK_USAGE_BYTES的定义如下:</p>
<pre><code>//5MB
 private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;
</code></pre><p>所以volley的默认缓存文件大小为5MB。这是DiskBasedCache中两个参数的构造方法，对缓存目录和缓存大小进行了赋值。</p>
<pre><code> public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {
    mRootDirectory = rootDirectory;
    mMaxCacheSizeInBytes = maxCacheSizeInBytes;
}
</code></pre><p>而缓存文件的真正创建操作，是在Volley.newRequestQueue()中的queue.start()方法内部进行：</p>
<pre><code>public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // CacheDispatcher是继承自Thread的类，负责从缓存中读取数据
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();
    ...
}
</code></pre><p>CacheDispatcher是继承自Thread的类，负责从缓存中读取数据，它的run()方法如下：</p>
<pre><code>  @Override
public void run() {
    if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    mCache.initialize();
    ...
}
</code></pre><p>mCache.initialize()进行缓存目录的创建：</p>
<pre><code>@Override
public synchronized void initialize() {
    //这里新建名为volley的文件夹
    if (!mRootDirectory.exists()) {
        if (!mRootDirectory.mkdirs()) {
            VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());
        }
        return;
    }
...
}
</code></pre><p>以上进行了缓存目录的创建，在DDMS的file explore中对应了如下目录：<br><img src="http://i4.buimg.com/588926/ca850075e724c103.png" alt=""></p>
<h2 id="响应结果的cacheEntry创建"><a href="#响应结果的cacheEntry创建" class="headerlink" title="响应结果的cacheEntry创建"></a>响应结果的cacheEntry创建</h2><p>缓存目录创建好了之后，在每次网络请求完成之后，就可以根据网络请求获得的response进行对应的缓存操作，由于具体的缓存文件创建和写入操作是在网络请求之后，所以缓存操作应该位于网络请求线程当中，来到mNetworkDispatcher中可以看到如下代码：</p>
<pre><code>NetworkResponse networkResponse = mNetwork.performRequest(request);      
           // 解析，并创建response.cacheEntry
           Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);

           if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {
               mCache.put(request.getCacheKey(), response.cacheEntry);
               request.addMarker(&quot;network-cache-written&quot;);
           }
</code></pre><p>第一个条件可以通过request.shouldCache(boolean shouldCache)来设置，第二个条件不为空。<br>mCache.put(request.getCacheKey(), response.cacheEntry)负责写入文件：<br>参数1：<br>request.getCacheKey()返回我们构建request时候传入的url(所以volley将request的url作为key来进行缓存)：</p>
<pre><code> public String getCacheKey() {
    return getUrl();
}
</code></pre><p>参数2：<br>response.cacheEntry的创建过程如下：</p>
<pre><code>public static Cache.Entry parseCacheHeaders(NetworkResponse response) {
    long now = System.currentTimeMillis();
    //map保存header
    Map&lt;String, String&gt; headers = response.headers;
    ...
    long softExpire = 0;
    long finalExpire = 0;
    long maxAge = 0;
    ...
    headerValue = headers.get(&quot;Date&quot;);
    if (headerValue != null) {
        serverDate = parseDateAsEpoch(headerValue);
    }
    //获得响应头中的Cache-Control字段，如Cache-Control:max-age=100,...
    headerValue = headers.get(&quot;Cache-Control&quot;);
    if (headerValue != null) {
        hasCacheControl = true;
        String[] tokens = headerValue.split(&quot;,&quot;);
        for (int i = 0; i &lt; tokens.length; i++) {
            String token = tokens[i].trim();
            //不缓存
            if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) {
                mustRevalidate = true;
            //取得服务器返回的Cache-Control的max-age值，单位为秒
            } else if (token.startsWith(&quot;max-age=&quot;)) {
                try {
                    maxAge = Long.parseLong(token.substring(8));
                } catch (Exception e) {
                }
            } 
            ...
        }
    }
    ...
    //根据max-age的值计算finalExpire
    if (hasCacheControl) {
        //毫秒，如当前时间为10，maxAge=40s,那么过期时间为10+40*1000
        softExpire = now（毫秒） + maxAge * 1000;
        finalExpire = mustRevalidate
                ? softExpire
                : softExpire + staleWhileRevalidate * 1000;
    } 
    ...
    //构建entry
    Cache.Entry entry = new Cache.Entry();
    //响应体
    entry.data = response.data;
    entry.etag = serverEtag;
    entry.softTtl = softExpire;
    //该缓存的过期时间点
    entry.ttl = finalExpire;
    entry.serverDate = serverDate;
    entry.lastModified = lastModified;
    //响应头
    entry.responseHeaders = headers;

    return entry;
}
</code></pre><p>上面有些代码的省略，这里的entry是根据response header来进行创建的，从最后entry的赋值可以知道，entry中主要保存了response的body、header、以及通过header计算而来的缓存过期时间，这样在再次访问该缓存的时候可以直接从entry中读取而不用每次从header中进行解析计算。</p>
<h2 id="将缓存写入文件"><a href="#将缓存写入文件" class="headerlink" title="将缓存写入文件"></a>将缓存写入文件</h2><p>上一步根据返回的response计算出了缓存的过期时间和其他信息（保存在entry中），接下来就是以url为key,以entry为value将结果写入文件：</p>
<pre><code>mCache.put(request.getCacheKey(), response.cacheEntry)
</code></pre><p>实现如下：</p>
<pre><code>public synchronized void put(String key, Entry entry) {
    //写之前判断缓存大小是否超过最大值，超过则删除部分缓存
    pruneIfNeeded(entry.data.length);
    //通过key找到对应的缓存文件，没有则创建
    File file = getFileForKey(key);
    try {
        BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));
        //将entry构造成只包含header的对象，不包含body，但包含body的大小
        CacheHeader e = new CacheHeader(key, entry);
        //将header写入文件
        boolean success = e.writeHeader(fos);
        if (!success) {
            fos.close();
            VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());
            throw new IOException();
        }
        //将body写入文件
        fos.write(entry.data);
        fos.close();
        //将&lt;key,cacheHeader&gt;存入linkedHashMap中
        putEntry(key, e);
        return;
    } catch (IOException e) {
    }
    boolean deleted = file.delete();
    if (!deleted) {
        VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());
    }
}
</code></pre><p>除了将header和body写入到文件之外，putEntry(key, e)方法会将<key,e>存入名为mEntries的linkedHashMap中，这个linkedhashmap用来保存最近使用过的元素，当缓存超过最大容量的时候，就会通过e.key来获得对应的缓存文件，进而删除。实现了LRU算法的效果。这一过程如下：</key,e></p>
<pre><code>private void pruneIfNeeded(int neededSpace) {
   //没有超过最大容量就直接返回
   if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) {
       return;
   }
   if (VolleyLog.DEBUG) {
       VolleyLog.v(&quot;Pruning old cache entries.&quot;);
   }

   long before = mTotalSize;
   int prunedFiles = 0;
   long startTime = SystemClock.elapsedRealtime();
   //获取迭代器
   Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();
   while (iterator.hasNext()) {
       Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();
       //获取之前putEntry(key,e)保存的e
       CacheHeader e = entry.getValue();
       //根据e.key找到缓存文件并删除
       boolean deleted = getFileForKey(e.key).delete();
       if (deleted) {
           //删除成功则更新size
           mTotalSize -= e.size;
       } else {
          VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,
                  e.key, getFilenameForKey(e.key));
       }
       //从linedhashmap中删除当前iterator所指的元素
       iterator.remove();
       prunedFiles++;
       //如果删除之后所剩占用的总空间&lt;最大容量*0.9(常量值为0.9f)则跳过该删除操作
       if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {
           break;
       }
   }

   if (VolleyLog.DEBUG) {
       VolleyLog.v(&quot;pruned %d files, %d bytes, %d ms&quot;,
               prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);
   }
</code></pre><p>所以在缓存方面，volley使用了linkedHashMap来保存<key,cacheheader>,通过遍历cacheHeader并统计所有cacheHeader.size的和便得到了当前所有缓存文件的总和，当缓存文件超过总容量的时候，再删除缓存文件直到文件总和等于0.9*maxSize。</key,cacheheader></p>
<p>通过linkedHashMap来保存<key,cacheheader>的原因是因为linkedHashMap控制元素的遍历顺序：</key,cacheheader></p>
<pre><code>/** Map of the Key, CacheHeader pairs */
private final Map&lt;String, CacheHeader&gt; mEntries =
        //ture代表按照访问顺序排序
        new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);
</code></pre><p>第三个参数true的效果是：<br>最近访问的元素会方法linkedHashMap的最后面，所以在删除文件的时候就可以直接删除第一个遍历到的元素对应的文件就行了，它就是最近最久未被访问的元素(LRU算法的思想)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volley的请求遵循以下步骤：</p>
<ol>
<li>将请求添加到缓存请求队列(由阻塞队列实现)</li>
<li>由cacheDispatcher根据请求的url作为key，在linkedHashmap中查找是否有值</li>
<li>值为空，则将请求添加到网络请求队列，值不为空但是过期也将添加到网络请求队列，值不为空且没有过期则直接返回缓存结果</li>
<li>网络请求执行，并缓存执行结果  </li>
</ol>
<p><strong>DiskBasedCache中名为entries的linkedHashmap中，保存的元素和文件缓存一一对应，这样在判断缓存是否存在的时候，就可以在运行时直接读取linkedHashmap而不用每次去读取文件来判断(读取内存当然比读取磁盘更快)</strong></p>
<pre><code>@Override
public synchronized Entry get(String key) {
    CacheHeader entry = mEntries.get(key);
    // if the entry does not exist, return.
    if (entry == null) {
        return null;
    }
    ...
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面简单地学习了volley的基本请求过程，那就是先访问缓存，缓存命中且没有过期就直接返回缓存的response，否则就进行网络请求，并对结果进行缓存，接下来再记录一下我对volley缓存部分的学习。&lt;/p&gt;
&lt;h2 id=&quot;缓存目录的创建&quot;&gt;&lt;a href=&quot;#缓存目录的创建&quot; class=&quot;headerlink&quot; title=&quot;缓存目录的创建&quot;&gt;&lt;/a&gt;缓存目录的创建&lt;/h2&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>安卓中的注解</title>
    <link href="http://yoursite.com/2017/04/26/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/04/26/安卓中的注解/</id>
    <published>2017-04-26T09:51:42.000Z</published>
    <updated>2017-04-30T14:44:58.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><p>java中的注解按照处理方式可分为运行时注解和编译时注解。</p>
<ul>
<li>运行时注解<br>注解上的值需要在运行的时候通过反射机制来解析注解，以便根据注解的值来确定下一步的操作</li>
<li>编译时注解<br>注解上的值在程序编译之后就已经完成了解析，在运行时可以直接根据解析的结果进行操作，编译时注解需要注解处理器(annotation processing tools,即apt)<a id="more"></a>来完成，其中apt的作用是扫描.java文件中的注解信息并根据这些注解信息在特定的目录下自动生成.java文件，这些文件和普通的.java文件没有区别，我们可以直接调用这些.java文件中的方法。</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>下面是一个典型的自定义注解的例子：</p>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BindView {
       int value() default 0;
}
</code></pre><p><strong>1.注解中变量的声明需要加()</strong><br><strong>2.当注解中只有一个变量时，最好声明为value(),这样就可以在使用注解时直接@DiView(1)而不用<br>@DiView(value=1)了</strong></p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>java提供了四种元注解，它们是：<br>@Target<br>@Retention<br>@Documented<br>@Inherited </p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>@Target表示该注解作用的对象，可选值如下：</p>
<p>@Target(ElementType.TYPE) //接口、类<br>@Target(ElementType.FIELD) //成员变量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //形参<br>@Target(ElementType.CONSTRUCTOR)  //构造方法<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>@Retention表示注解的生命期，它的可选项如下：<br>@Retention(RetentionPolicy.SOURCE)  //     注解只存在与源代码中<br>@Retention(RetentionPolicy.CLASS)  // 注解可存在与字节码文件中<br>@Retention(RetentionPolicy.RUNTIME)  // 注解可存活到运行时，在运行时仍然可以获取到该注解的值</p>
<p>除了以上两个元注解，java还提供了<br>@Documented  //  表示该注解会存在javadoc中<br>@Inherited  //  表示该注解可以被子类继承<br>两个元注解。</p>
<p><strong>@Inherited只有作用在类上能被子类继承，这里的继承指的是当父类上存在该注解时，其子类即使不声明该注解，但依然可以获取到该注解的值</strong></p>
<p><strong>注解本身不支持继承，即不能定义@interface child extends parent（其中parent为注解）</strong></p>
<h2 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h2><p>为了对比两种解析方式，基于上面定义的注解BindView,来代替findViewById()这个方法。</p>
<h3 id="通过反射"><a href="#通过反射" class="headerlink" title="通过反射"></a>通过反射</h3><pre><code>public class ViewBinder {

public static void bindwith(Activity activity) {
    Class class = activity.getClass();
    //遍历成员变量
    for (Field field : class.getDeclaredFields()) {
        //处理字段
        if (field.isAnnotationPresent(BindView.class)) {
            IView anno = field.getAnnotation(IView.class);
            int value = anno.value();
            try {
                //若变量为private则必须加上这一句
                field.setAccessible(true);
                //意为将activity对象的field变量赋值为activity.findViewById(value)
                field.set(activity, activity.findViewById(value));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
            }
        }
    }
}
</code></pre><p>现在在Activity中就可以这样使用该注解来代替findViewById()了： </p>
<pre><code>public class ReflectActivity extends AppCompatActivity {

       @IView(R.id.button)
    Button mButton;

       @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ViewBinder.bindwith(this);
    }
}
</code></pre><p>这就是运行时通过反射来解析注解，但是反射可能对性能有部分影响。</p>
<h3 id="通过自定义apt"><a href="#通过自定义apt" class="headerlink" title="通过自定义apt"></a>通过自定义apt</h3><p>相比与反射，这种方式在编译时就完成了注解的解析，运行时直接调用就可以了，所以性能方面较好。<br>在Android Studio中使用这种方式解析注解的步骤如下：</p>
<h4 id="新建module、添加依赖"><a href="#新建module、添加依赖" class="headerlink" title="新建module、添加依赖"></a>新建module、添加依赖</h4><ol>
<li>新建<strong>java library</strong>类型的module，并对该module添加依赖：<br><img src="http://i4.buimg.com/567571/85ac8441ef7d9374.png" alt=""><br><strong>auto-service依赖用于在项目中快速注册注解</strong><br><strong>javapoet提供了一系列方法用于在注解解析阶段根据注解形成java类并生成.java文件，避免了我们自己通过字符串的方式构造类</strong>  </li>
<li>在app module的gradle文件中添加依赖：<br><img src="http://i1.piimg.com/567571/f007411b745745a9.png" alt=""><br>lib是我新建的java librayr module名称</li>
<li>在project的gradle文件中添加依赖：<br><img src="http://i2.muimg.com/567571/73ceb8a5acb437d6.png" alt=""></li>
</ol>
<p><strong>以上方法用到了android-apt插件，不过这个插件貌似第三方已经停止维护，取而代之的是Google官方的annotationProcessor</strong><br><strong>如果使用annotationProcessor则不需要添加android-apt插件的依赖，只需要将apt project(‘:lib’)改为annotationProcessor(‘:lib’)即可</strong></p>
<h4 id="编写apt"><a href="#编写apt" class="headerlink" title="编写apt"></a>编写apt</h4><p>1.自定义注解bind，作用于类：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface Bind {
}
</code></pre><p>2.自定义注解bindView作用与成员变量：</p>
<pre><code>@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface bindView {
    int value() default 0;
}
</code></pre><p>3.编写注解处理器</p>
<pre><code>@AutoService(Processor.class)
public class MyProcessor extends AbstractProcessor {

private Elements elementUtils;
//返回支持的注解类型
@Override
public Set&lt;String&gt; getSupportedAnnotationTypes() {

    return Collections.singleton(Bind.class.getCanonicalName());
}
//扫描所有注解并生成.java文件
@Override
public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) {
    //扫描所有被@bind注解修饰的类
    Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Bind.class);
    //遍历所有被@bind修饰的类
    for (Element element : elements) {
        //TypeElement代表接口或者类
        TypeElement typeElement = (TypeElement) element;
        //获得类的所有成员变量
        List&lt;? extends Element&gt; members = elementUtils.getAllMembers(typeElement);
        //利用Javapoet生成方法
        MethodSpec.Builder bindViewMethodSpecBuilder = MethodSpec.methodBuilder(&quot;bindView&quot;)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(TypeName.VOID)
                .addParameter(ClassName.get(typeElement.asType()), &quot;activity&quot;);
        //扫描所有成员变量并取得其上@bindView注解的值
        for (Element item : members) {
            bindView diView = item.getAnnotation(bindView.class);
            if (diView == null) {
                continue;
            }
            //为方法添加语句
            bindViewMethodSpecBuilder.addStatement(String.format(&quot;activity.%s = (%s) activity.findViewById(%s)&quot;, item.getSimpleName(), ClassName.get(item.asType()).toString(), diView.value()));
        }
        //利用javapoet生成类
        TypeSpec typeSpec = TypeSpec.classBuilder(&quot;DI&quot; + element.getSimpleName())
                .superclass(TypeName.get(typeElement.asType()))
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(bindViewMethodSpecBuilder.build())
                .build();
        //将生成的写入.java文件
        JavaFile javaFile = JavaFile.builder(getPackageName(typeElement), typeSpec).build();
        try {
            javaFile.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return false;
}
//获取包名，用于指定生成的.java文件目录
private String getPackageName(TypeElement typeElement) {
    return elementUtils.getPackageOf(typeElement).getQualifiedName().toString();
}
//解析之前最先调用
@Override
public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    elementUtils = processingEnv.getElementUtils();
}
//jdk的版本
@Override
public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.latestSupported();
}
}
</code></pre><p>最终我们在activity中就可以这样使用我们自己定义的注解了：  </p>
<pre><code>@Bind()
public class MainActivity extends AppCompatActivity {
    @bindView(R.id.button)
    Button mButton;
    @bindView(R.id.image)
    ImageView imageView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        DIMainActivity.bindView(this);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注解的分类&quot;&gt;&lt;a href=&quot;#注解的分类&quot; class=&quot;headerlink&quot; title=&quot;注解的分类&quot;&gt;&lt;/a&gt;注解的分类&lt;/h2&gt;&lt;p&gt;java中的注解按照处理方式可分为运行时注解和编译时注解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时注解&lt;br&gt;注解上的值需要在运行的时候通过反射机制来解析注解，以便根据注解的值来确定下一步的操作&lt;/li&gt;
&lt;li&gt;编译时注解&lt;br&gt;注解上的值在程序编译之后就已经完成了解析，在运行时可以直接根据解析的结果进行操作，编译时注解需要注解处理器(annotation processing tools,即apt)
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>retrofit+okhttp网络请求本地缓存</title>
    <link href="http://yoursite.com/2017/04/09/retrofit-okhttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/04/09/retrofit-okhttp网络请求本地缓存/</id>
    <published>2017-04-09T09:04:50.000Z</published>
    <updated>2017-06-09T12:06:05.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客最后修改于 5/22/2017 7:07:53 PM<br>移动端缓存的目的当然是希望用户在没有网络的情况下也能查看缓存过的内容对吧，以前学习Volley一次请求过程的时候其实已经接触到网络请求的缓存了<br><a id="more"></a></p>
<h2 id="移动端缓存的典型作用"><a href="#移动端缓存的典型作用" class="headerlink" title="移动端缓存的典型作用"></a>移动端缓存的典型作用</h2><ol>
<li>没有网络的时候，可以从缓存中获取到内容进而显示，虽然缓存中的内容不一定是最新的，但一定程度提高了用户体验。</li>
<li><p>节省流量，当用户频繁刷新获取数据时，由于来自服务器的数据很可能在短时间内没有变化，在数据无变化的情况下我们仍然使用自己缓存的数据，既节省流量又降低了服务端的压力。（该功能需要服务器端根据request header中的字段进行判断，进而决定返回304还是200，返回304的话，客户端就直接使用缓存就行了）</p>
<h2 id="网络缓存的原理简析"><a href="#网络缓存的原理简析" class="headerlink" title="网络缓存的原理简析"></a>网络缓存的原理简析</h2><p>就拿经常使用的浏览器来说，发起请求的简单图解如下：<br><img src="http://i4.buimg.com/567571/b08c52fc5c66dd38.png" alt=""><br>图中涉及：</p>
</li>
<li><p>浏览器本地缓存</p>
</li>
<li>代理服务器缓存</li>
</ol>
<p>其中代理服务器缓存是共享的，比如使用西南大学校园网的所有浏览器都可能使用的是同一台西南大学的代理服务器。</p>
<h3 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h3><p>条件get方法指的是在request header中添加了if-modified-since:sometime(某个时间)字段的get请求，这个sometime一般在上一次请求时由response header中的last-modified:sometime指定，当服务器接收到一个条件get请求的时候，会将request header中if-modified-since指定的时间与最后修改时间进行比较，若相同则返回304，代表未修改，那么浏览器就可以继续使用缓存的数据，否则会返回200和新的数据，浏览器再进行缓存的更新。</p>
<p>现如今，条件get方法也可以通过response header的Etag返回一个标识（字母+数字），而request  header则添加的是if-none-match字段，原理类似if-modified-since。</p>
<h3 id="与缓存相关的头字段"><a href="#与缓存相关的头字段" class="headerlink" title="与缓存相关的头字段"></a>与缓存相关的头字段</h3><p>不同版本的http协议中缓存相关头字段有区别，在okHttp中控制缓存主要通过拦截器来重写request header的Cache-Control字段来实现，关于Cache-Control字段以及更多缓存相关字段在一下链接中给出了详细的解释：<br><a href="http://www.tuicool.com/articles/URJjAb" target="_blank" rel="external">http缓存头字段详解</a> </p>
<h2 id="retrofit-okHttp实现本地缓存"><a href="#retrofit-okHttp实现本地缓存" class="headerlink" title="retrofit+okHttp实现本地缓存"></a>retrofit+okHttp实现本地缓存</h2><p>okHttp不需要和retrofit搭配也可以实现缓存，只是retrofit以接口和注解的方式来进行get和post方法的定义更加简洁。<br>该缓存功能主要是通过在拦截器里修改response header，实现缓存的具体代码：</p>
<pre><code>//getInstance方法用于获取一个retrofit 请求对象
 public static &lt;T&gt; T getInstance(Class&lt;T&gt; classType) {
    //设置cache文件的大小
    int cacheSize = 20 * 1024 * 1024;
    //在指定目录下创建缓存文件
    Cache cache = new Cache(new File(APP.getApplication().getCacheDir(), &quot;okhttpCache&quot;), cacheSize);
    //创建okhttpClient对象并添加拦截器(用于rewrite请求头和响应头)
    OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .cache(cache)
            .addInterceptor(mNETWORK_INTERCEPTOR)
            .addNetworkInterceptor(mNETWORK_INTERCEPTOR)
            .addInterceptor(mHttpLoggingInterceptor)
            .build();
    //retrofit配合rxjava发送请求
    Retrofit retrofit = new Retrofit.Builder()
            .baseUrl(NewsApi.NEWS_API_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            //adapter用于在retrofit接口中返回rxjava的observable对象
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .build();
    T t = retrofit.create(classType);
    return t;
}
</code></pre><p>接下来是拦截器的具体代码(okhttp在发送request之前和获得response之后都会调用到拦截器的方法)：</p>
<pre><code> private static final Interceptor mNETWORK_INTERCEPTOR = new Interceptor() {
    @Override
    public okhttp3.Response intercept(Chain chain) throws IOException {
        okhttp3.Request request = chain.request();
        okhttp3.Response originalResponse = chain.proceed(request);

        //读取retrofit接口上的@Headers里的配置，并设置到response header里
        String cacheControl = request.cacheControl().toString();
        return originalResponse.newBuilder()
                    .header(&quot;Cache-Control&quot;, cacheControl)
                    .removeHeader(&quot;Pragma&quot;)
                    .build();
    }
};
</code></pre><p>下面是retrofit接口的代码：</p>
<pre><code>public interface NewsTypeApi {
//设置cache新鲜时间600s0，即获得第一次获得response并cache之后，该cache在600s之后失效
@Headers(&quot;Cache-Control: max-age=600&quot;)
@GET(&quot;index&quot;)
Observable&lt;NewsBean&gt; call(@Query(&quot;type&quot;) String type, @Query(&quot;key&quot;) String key);
</code></pre><p>}</p>
<h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p>上述代码简单的工作流程可概括为下图（自己画的，有点丑）<br><img src="http://i1.piimg.com/567571/d02a0eda2ab4c361.png" alt=""></p>
<p>因为在retrofit的get方法中设置了max-age=600，就意味着cache在600s后过期，而okhttp会把过期时间记录到缓存文件里，在下次访问命中该缓存时就首先会判断缓存是否过期，过期又没网的话是自然是读取不到任何数据的，此时就应该提醒用户联网重新获取数据了。</p>
<h2 id="max-age和max-stale"><a href="#max-age和max-stale" class="headerlink" title="max-age和max-stale"></a>max-age和max-stale</h2><p>这两者都和缓存有效期相关，举个例子来帮助理解。</p>
<p>Cache-Control: max-age=60,max-stale=60<br>意味着我获得的response缓存将在60秒之后过期，但是过期之后并不意味着不可用了，因为max-stale=60，所以我仍然可以在过期之后的60秒内使用该缓存。<br>那么该缓存存在的总时间=60+60=120秒，超过120秒之后，该缓存将被从文件系统上删除(我们知道okhttp缓存是保存在文件上的)<br><strong>max-stale只在请求头有效，max-age请求头和响应头均有效</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不知道你发现没有，我们到这里只是实现了缓存中的第一个功能：<br>——在没网的时候访问缓存数据，这样在拦截器里强行修改响应头虽然不好，但在服务器没有给我们返回缓存相关的header时，这倒是一种可行的办法，假如response header里本来就包含cache control字段了，也就完全不需要我们来手动配置拦截器了。<br>如果要实现第二个功能——有网的时候，用户刷新数据从服务器得到的数据可能和此刻本地缓存的数据一样(比如新闻客户端中，刷新之后可能新闻内容并没有增加)，那么此刻服务器就应该返回304代码，告诉客户端没有数据改变，你可以继续使用你的缓存，这样就节省了流量。</p>
<p>客户可以通过条件get方法来查询服务器资源是否修改，但是这需要服务端的支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客最后修改于 5/22/2017 7:07:53 PM&lt;br&gt;移动端缓存的目的当然是希望用户在没有网络的情况下也能查看缓存过的内容对吧，以前学习Volley一次请求过程的时候其实已经接触到网络请求的缓存了&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="网络请求缓存" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android判断网络是否连接</title>
    <link href="http://yoursite.com/2017/04/05/Android%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/04/05/Android判断网络是否连接/</id>
    <published>2017-04-05T05:12:32.000Z</published>
    <updated>2017-05-11T11:22:08.598Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用retrofit+okhttp实现网络请求本地缓存的时候(在服务端不支持的情况下)，遇到本地缓存始终不能读取到的问题，一开始还以为Cache-Control设置错了，结果最终发现是判断网络状态出了问题，在这里记录一下。<br><a id="more"></a><br>最终需要实现的效果是，有网就访问服务器，没网就访问缓存(对网络请求的缓存由okHttp自带，Volley也具有该功能)，关于缓存部分在下一篇博客记录，这里简单记录一下判断网络状态的方法：  </p>
<h2 id="判断网络是否连接"><a href="#判断网络是否连接" class="headerlink" title="判断网络是否连接"></a>判断网络是否连接</h2><pre><code>public class NetUtil {
    public static boolean isNetworkAvaliable(){
        ConnectivityManager connectivityManager= (ConnectivityManager) APP.getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);
        //没网时info返回为null
        NetworkInfo info = connectivityManager.getActiveNetworkInfo();
        if (info != null &amp;&amp; info.isConnected()) {
            //这层if可要可不要
            if (info.getState() == NetworkInfo.State.CONNECTED) {
                return true;
            }
        }
        return false;
    }
}
</code></pre><p><strong>我的代码如下：</strong>  </p>
<pre><code>public class NetUtil {
      public static boolean isNetworkAvaliable(){
            ConnectivityManager connectivityManager= (ConnectivityManager) APP.getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);
        //若网络没有开启，info的返回值为null
            NetworkInfo info = connectivityManager.getActiveNetworkInfo();
         return info.isConnect();
        }
}  
</code></pre><p>有网的时候能够正常执行返回true，没网的时候由于返回的info=null,进而影响到网络的判断。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用retrofit+okhttp实现网络请求本地缓存的时候(在服务端不支持的情况下)，遇到本地缓存始终不能读取到的问题，一开始还以为Cache-Control设置错了，结果最终发现是判断网络状态出了问题，在这里记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android网络状态" scheme="http://yoursite.com/tags/android%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>算法复习之——堆排序</title>
    <link href="http://yoursite.com/2017/03/27/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/03/27/算法复习之——堆排序/</id>
    <published>2017-03-27T04:38:27.000Z</published>
    <updated>2017-05-11T11:18:23.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆排序利用完全二叉树的思维来进行堆排序的实现，但是并不需要我们在排序的时候建立一棵完全二叉树。这一切都是基于数组之间元素的交换来进行的。<br><a id="more"></a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p><img src="http://i1.piimg.com/567571/92099c39300929ee.png" alt=""><br>在完全二叉树中，假如结点从1开始编号，父结点和子结点之间的序号存在如下关系：<br>若父结点序号为i，则孩子结点序号：<br>左孩子——2 <em> i<br>右孩子——2 </em> i+1<br>最后一个非叶子结点的编号——n/2（n为结点总个数）<br><strong>因为数组的下标从0开始，所以在对数组进行堆排序的时候，上述关系变为如下所示：</strong><br><strong>左孩子——2 * i+1</strong><br><strong>右孩子——2 * i+2</strong><br><strong>最后一个非叶子结点的编号——n/2-1</strong></p>
<h3 id="大顶堆和小顶堆"><a href="#大顶堆和小顶堆" class="headerlink" title="大顶堆和小顶堆"></a>大顶堆和小顶堆</h3><p>大顶堆——每个父结点的值大于子结点的值<br>小顶堆——每个父结点的值小于子结点的值</p>
<h2 id="堆排序介绍"><a href="#堆排序介绍" class="headerlink" title="堆排序介绍"></a>堆排序介绍</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li>将数组与二叉树等价看待——堆排序是将待排序的数组看作一颗完全二叉树,该二叉树的结点从上到下、从左到右对应数组中的每一个元素，二叉树的下标编号即为数组的索引编号。</li>
<li>构建堆(大顶堆或小顶堆)——从最后一个非叶子结点开始，将该结点和其孩子结点进行比较，并把三者的最小值或者最大值与该结点进行交换。使得这三者在局部上成为大顶堆或小顶堆。如此进行直到到达根结点</li>
<li>构建堆完成之后，将堆顶元素与堆的最后一个元素交换，并剔除最后一个元素，继续执行第二步，将剩下的元素调整为大顶堆或者小顶堆，直到所有元素被剔除。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>现在的待排序数组为：<br>4 1 3 2 16 9 10 14 8 7</p>
<h4 id="一-建立大顶堆"><a href="#一-建立大顶堆" class="headerlink" title="一.建立大顶堆"></a>一.建立大顶堆</h4><ol>
<li>首先将该数组视为一棵完全二叉树：<br><img src="http://i1.piimg.com/567571/565c611ef8a50028.png" alt="">  </li>
<li>找到最后一个非叶子结点值为16（编号5），将其与左孩子比较，因为16&gt;7，不交换，则对16的前一个结点2(编号4)，进行同样操作，比较2和其孩子结点，因为14在三者中最大，所以将2和14交换得到如下：<br><img src="http://i1.piimg.com/567571/3f20d503d8b4cc03.png" alt=""></li>
<li>继续对14(编号为4)的前一个结点3(编号为3)进行上述操作得到下图：<br><img src="http://i1.piimg.com/567571/2e31450db18ba89d.png" alt=""></li>
<li>对1(编号为2)的结点进行调整之后，发现值为1和7的结点之间不满足大顶堆性质，将1视为当前结点，进行上述2的调整（此时应该交换1和7）：<br><img src="http://i1.piimg.com/567571/f97ab646d28ffaee.png" alt="">  </li>
<li>类似步骤省略，最终由该数组形成的大顶堆如下:<br><img src="http://i4.buimg.com/567571/1c54b90babd19b8e.png" alt=""><h4 id="二-排序"><a href="#二-排序" class="headerlink" title="二.排序"></a>二.排序</h4></li>
<li>将堆顶元素和最后一个元素交换，那么最大的元素就到了数组的最后一位：<br><img src="http://i1.piimg.com/567571/12b24c7599b480fa.png" alt=""></li>
<li>将剩下的元素调整为堆：<br><img src="http://i1.piimg.com/567571/55c9d7d79bcfceb2.png" alt="">  </li>
<li>重复1和2，最终整个数组有序。</li>
</ol>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><pre><code>public class Test {
    public static void main(String[] args) {
        int[] a = { 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 };
        buildHeap(a);
        heapSort(a);
        System.out.println(Arrays.toString(a));
    }

    private static void heapSort(int[] a) {
        for (int i = a.length - 1; i &gt;= 1; i--) {
            //交换第i个元素和堆顶元素
            swap(a, 0, i);
            //调整剩下的元素调整为堆
            adjustHeap(a, i, 0);
        }
    }

    private static void buildHeap(int[] a) {
        // 数组中最后一个非叶子节点的下标
        int startIndex = a.length / 2 - 1;
        //从该结点向前直到根结点，调整为堆
        for (int i = startIndex; i &gt;= 0; i--) {
            adjustHeap(a, a.length, i);
        }
    }

    private static void adjustHeap(int[] a, int length, int index) {
        //若当前结点存在左孩子
        while ((2 * index + 1) &lt; length) {
            int leftChild = 2 * index + 1;
            int rightChild = leftChild + 1;
            int max = leftChild;
            //若当前结点存在右孩子
            if (rightChild &lt; length) {
                // 将较大的一个孩子下标赋值给max
                max = a[leftChild] &gt; a[rightChild] ? leftChild : rightChild;
            }
            // 建立局部大顶堆，保证三者中最大的元素成为父结点
            if (a[index] &lt; a[max])
                swap(a, max, index);
            //因为交换之后可能导致子结点之间不满足堆的性质，还需要对子结点进行相同操作
            index = max;
        }
    }

    // 交换数组中下标为max和index对应的元素，因为直接操作数组，所以可以完成交换
    private static void swap(int[] a, int max, int index) {
        int temp = a[max];
        a[max] = a[index];
        a[index] = temp;
    }
}
</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="http://i1.piimg.com/567571/4ec188473ac93a28.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;堆排序利用完全二叉树的思维来进行堆排序的实现，但是并不需要我们在排序的时候建立一棵完全二叉树。这一切都是基于数组之间元素的交换来进行的。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法复习之——直接插入排序</title>
    <link href="http://yoursite.com/2017/03/22/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/03/22/算法复习之——直接插入排序/</id>
    <published>2017-03-22T09:10:04.000Z</published>
    <updated>2017-03-22T09:34:15.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直奔主题"><a href="#直奔主题" class="headerlink" title="直奔主题"></a>直奔主题</h2><p>直接插入排序的基本思想：<br>首先将数组的第一个元素看成有序的、长度为1的数组，从第二个元素开始将第二个元素插入到前面的有序数组中合适的位置，使得有序数组变为长度为2的有序数组，以此循环进行，直到遍历完原来数组的所有元素。最终使得整个数组有序。<br><a id="more"></a></p>
<h2 id="怎么找到插入的合适位置？"><a href="#怎么找到插入的合适位置？" class="headerlink" title="怎么找到插入的合适位置？"></a>怎么找到插入的合适位置？</h2><p>要找到插入的合适位置，可以在前部分有序数组中从后往前搜索，直到找到第一个小于待排元素的元素，合适的位置即为该元素的下一个位置，寻找位置的同时将有序数组中大于待排元素的所有元素后移一位。即<br>a[j+1]=a[j]。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>现在有如下数组：<br>(5) 2 7 6 9<br>将5看做长度为1的有序数组，从2开始，首先将2保存下来(int temp=a[i])，在有序数组中从后往前搜索，5&gt;2，所以用5将2覆盖，此时数组为：5 5 7 6 9，继续向前搜索发现刚才搜索的5已经是有序数组的第一个元素，代表有序数组中没有比2小的数，所以将2放在第一位得到以下数组：<br>(2 5) 7 6 9<br>对下一个数7继续上述操作，得到:<br>(2 5 7) 6 9<br>对6继续上述操作，得到：<br>(2 5 6 7) 9<br>最终得到：<br>2 5 6 7 9</p>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><pre><code>public class InsertSort {

public static void main(String[] args) {
    int[] a = { 23, 100, 55, 2, 56, 2, 99, 0, 23, 44, 103, 1, 2000 };
    insertSort(a);
    System.out.println(Arrays.toString(a));
}

private static void insertSort(int[] a) {
    // 从第二个元素开始进行插入排序
    for (int i = 1; i &lt; a.length; i++) {
        // j是i的前一个元素
        int j = i - 1;
        // 因为可能进行有序数组原色后移，先保存先来当前待排序的元素
        int temp = a[i];
        // 在有序数组中找到第一个小于待排元素的位置，同时把大于待排元素的数往后移动一个位置
        while (j &gt;= 0 &amp;&amp; a[j] &gt;= temp) {
            a[j + 1] = a[j];
            j--;
        }
        // j是有序数组中第一个小于待排元素的元素，待排元素应该放在它的下一位
        a[j + 1] = temp;
    }
    }
}
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://i2.buimg.com/567571/0bc4937e5b7ab36b.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;直奔主题&quot;&gt;&lt;a href=&quot;#直奔主题&quot; class=&quot;headerlink&quot; title=&quot;直奔主题&quot;&gt;&lt;/a&gt;直奔主题&lt;/h2&gt;&lt;p&gt;直接插入排序的基本思想：&lt;br&gt;首先将数组的第一个元素看成有序的、长度为1的数组，从第二个元素开始将第二个元素插入到前面的有序数组中合适的位置，使得有序数组变为长度为2的有序数组，以此循环进行，直到遍历完原来数组的所有元素。最终使得整个数组有序。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="插入排序" scheme="http://yoursite.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法复习之——快速排序</title>
    <link href="http://yoursite.com/2017/03/22/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/03/22/算法复习之——快速排序/</id>
    <published>2017-03-22T06:57:58.000Z</published>
    <updated>2017-03-22T08:03:12.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h2><p>自从上一篇关于Volley的文章之后，被实习折磨的我就基本停止了更博，一方面想急着找实习，另一方面却又一直感觉自己学的知识不是特别扎实，复习了几天也不知道复习的效果到底怎样，加上昨天收到阿里的一面，问得比较基础（全是项目相关）感觉也还算顺利，不过我有种预感，可能挂了，还是一步一步慢慢来吧。<br><a id="more"></a></p>
<h2 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h2><p>先来解释一下快排的基本步骤：</p>
<ol>
<li>选择基准元素（一般为数组的第一个元素）</li>
<li>通过第一次划分将大于基准的元素放置到基准元素的后面，将小于基准的元素放置到基准的前面，这样整体看来，基准之前的元素、基准元素、基准之后的元素三者之间变成了有序的。</li>
<li>分别对位于基准元素之前和之后的部分进行相同的操作，最终整个数组有序。</li>
</ol>
<h2 id="每次划分的基本操作"><a href="#每次划分的基本操作" class="headerlink" title="每次划分的基本操作"></a>每次划分的基本操作</h2><p>划分的基本思想是首先保存基准的值，再设置两个游标，low和high，分别指向当前数组的第一个和最后一个元素，首先从high开始，向前搜索到第一个小于基准的元素，并用该元素覆盖基准（此时相当于此处形成了一个重复的元素）；再从low开始，向后搜索到第一个大于基准的元素，用此元素覆盖前一步所形成的重复元素，重复这两个步骤知道low==high。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>一个简单数组如下（基准为5）：<br>首先把基准5保存下来，int povit=a[low]，此时可以认为5的位置形成了一个坑。<br>5(坑)  7  3  4  9  （low=1，high=3）<br>第一步：<br>从9开始向前搜索到第一个小于基准的元素为4，用4覆盖5（因为4去覆盖了5位置上的坑，所以原来4的位置上形成了坑），得到数组如下：<br>4   7   3   4(坑)  9  （low=1，high=3）<br>第二步：<br>从7开始向后搜索到第一个大于基准的元素为7，用7覆盖4位置上形成的坑，结果如下：<br>4  7(坑)  3  7  9  （low=1，high=3）<br>第三步：<br>重复第一步，从后向前搜索下一个小于基准的元素为3，同理进行填坑，结果如下：<br>4  3  3(坑)  7  9  （low=1，high=2）<br>第四步：<br>重复第二步，从前向后搜索下一个大于基准的元素（执行low++），此时low==high==2，结束搜索，用保存的基准值 povit=5 填坑，得到以下数组：  </p>
<p>4  3  5  7  9</p>
<p>经过一次划分，大于5的元素排列到了5的后面，小于5的排列到了5的前面，接下来就递归对5的前半部分和后半部分进行划分操作。最终使得整个数组有序。</p>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><p>以上的方法叫做填坑法，还有基于交换的快排，不过我更喜欢填坑的方式，下面是填坑法的快排代码：  </p>
<pre><code>public class QuickSort {
    public static void main(String[] args) {
        int[] a = { 23, 100, 55, 2, 56, 2, 99 };
        quickSort(a, 0, a.length - 1);
        System.out.println(Arrays.toString(a));
    }

    private static void quickSort(int[] a, int low, int high) {
        if (low &lt; high) {
            // 获得每次划分之后的基准元素位置
            int q = partition(a, low, high);
            // 前半部分进行快排
            quickSort(a, low, q - 1);
            // 后半部分进行快排
            quickSort(a, q + 1, high);
        }
    }

    private static int partition(int[] a, int low, int high) {
        // 保存每次划分的基准元素
        int pvoit = a[low];
        while (low &lt; high) {
            // 从后向前搜索第一个小于基准的元素位置
            while (low &lt; high &amp;&amp; a[high] &gt;= pvoit)
                high--;
            // 填坑，但high的位置上形成了新的坑
            a[low] = a[high];
            // 从前向后搜索第一个大于基准的元素位置
            while (low &lt; high &amp;&amp; a[low] &lt;= pvoit)
                low++;
            // 填坑，low的位置形成了新的坑
            a[high] = a[low];
        }
        // 当循环结束时，low==high
        // 用最开始保存的pvoit填最后一个形成的坑
        a[high] = pvoit;
        return high;
    }
}
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://i1.piimg.com/567571/3c7658edbe3b193a.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;自从上一篇关于Volley的文章之后，被实习折磨的我就基本停止了更博，一方面想急着找实习，另一方面却又一直感觉自己学的知识不是特别扎实，复习了几天也不知道复习的效果到底怎样，加上昨天收到阿里的一面，问得比较基础（全是项目相关）感觉也还算顺利，不过我有种预感，可能挂了，还是一步一步慢慢来吧。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="快排" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>volley的简单分析</title>
    <link href="http://yoursite.com/2017/02/28/volley%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/28/volley学习之网络请求过程/</id>
    <published>2017-02-28T05:05:28.000Z</published>
    <updated>2017-04-30T09:55:22.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Volley简介"><a href="#Volley简介" class="headerlink" title="Volley简介"></a>Volley简介</h2><p>众所周知，Volley是google在2013年开源的一款异步异步异步http网络请求库，采用Volley进行网络请求非常简单。那么怎样个异步法？最简单的解释就是：<br>使用Volley你不用再像原生的HttpUrlConnection一样new Thread(new runable());新开工作线程这些事Volley都帮你做了。<br>Volley为http请求提供了如下的保障：<br><a id="more"></a></p>
<ol>
<li>response缓存。Volley内部维护了一个cache，用来对网络请求的结果进行缓存，再次发起该请求时会首先访问cache，当请求内容和上次相同时会直接从cache返回数据，避免重复的网络请求。</li>
<li>request请求队列，Volley会将通过request.add()方法添加的request放置在请求队列，并从该队列中逐一取出请求进行请求。并支持请求优先级的设置。</li>
<li>response分发。Volley采用异步的请求方式，请求成功并获得返回值时会在工作线程中对结果进行解析，并将response分发到主线程，意味着在Volley的回调方法中，代码直接运行在主线程，方便了UI更新等操作。这一点和okHttp有很大区别，okHttp异步方式的回调仍然运行在工作线程。这样不同的实现也各有各的好处。</li>
<li>支持request的自定义，Volley原生request包括了JsonRequest、JsonArrayReuqest、ImageRequest和StringResquest四种，分别用于json对象、json数组以及字符串类型的返回值请求，除此以外，Volley允许继承Request类实现自己的请求，比如你可以实现返回一个JavaBean的请求。</li>
</ol>
<p>Volley适合频繁但数据量不大的网络请求，例如常见API调用，并不适合大文件的下载。Volley将整个response加载到内存并进行操作（可以是解析等操作）大文件可能会引起OOM<br><a href="https://developer.android.google.cn/training/volley/index.html" target="_blank" rel="external">官网对Volley的介绍</a></p>
<h2 id="Volley简单使用"><a href="#Volley简单使用" class="headerlink" title="Volley简单使用"></a>Volley简单使用</h2><p>最简单Volley的使用包括三个步骤：</p>
<ol>
<li>创建RequestQueue</li>
<li>创建Request</li>
<li><p>将Request添加到RequestQueue</p>
<pre><code> RequestQueue requestQueue = Volley.newRequestQueue(context);
StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() {
    @Override
    public void onResponse(String response) {
     //这里可以更新UI
    }
        }, new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {

    }
});
requestQueue.add(stringRequest);
</code></pre></li>
</ol>
<p>本文的重点是分析Volley的工作流程，各种请求的具体使用可以参考以下链接：<br><a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">郭霖教你学Volley</a></p>
<h2 id="Volley原理解析"><a href="#Volley原理解析" class="headerlink" title="Volley原理解析"></a>Volley原理解析</h2><p>先来一张Volley工作流程图镇楼：<br><img src="http://p1.bpimg.com/567571/1ffd5fe806e3cf35.png" alt=""><br>Volley中包括以下几种线程：</p>
<ul>
<li>缓冲读取线程(cacheDispatcher)——用于从缓冲中获取数据(继承自Thread)</li>
<li>网络请求线程(networkDispatcher)——用于发送网络请求来获取数据(继承自Thread)</li>
<li>response分发线程(mResponsePoster)——用于将请求结果(可能来自cache和网络)分发到主线程(Executor对象)</li>
</ul>
<h3 id="1-RequestQueue的创建"><a href="#1-RequestQueue的创建" class="headerlink" title="1.RequestQueue的创建"></a>1.RequestQueue的创建</h3><p>既然使用Volley首先创建的是RequestQueue对象，那我们就从Volley.newRequestQueue(context)方法开始。该静态方法通过调用重载的静态方法，内部调用构造方法创建一个requestQueue对象：</p>
<pre><code>public static RequestQueue newRequestQueue(Context context, HttpStack stack) {    
    //创建缓存
    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);

    String userAgent = &quot;volley/0&quot;;
    try {
        String packageName = context.getPackageName();
        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
        userAgent = packageName + &quot;/&quot; + info.versionCode;
    } catch (NameNotFoundException e) {
    }

    if (stack == null) {
        //API9及以上则使用HttpUrlConnection
        if (Build.VERSION.SDK_INT &gt;= 9) {
            stack = new HurlStack();
        } else {
            //小于9则使用HttpClient
            // Prior to Gingerbread, HttpUrlConnection was unreliable.
            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }
    //用于后面的网络请求
    Network network = new BasicNetwork(stack);
    //根据设置的缓存目录创建请求队列
    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    //启动请求队列
    queue.start();
    return queue;
}
</code></pre><p>从上面的代码可以发现，Volley内部是采用HttpUrlConnection或者HttpClient进行网络请求的(HttpClient已经废弃不再维护)。</p>
<p>我们重点关注一下这一行代码：</p>
<pre><code>RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
</code></pre><p>以上代码创建了一个新的请求队列。并传入DiskBasedCache(cacheDir)来根据相应目录初始化缓存。<br>跟踪上述构造方法，发现调用了另一个三个参数的构造方法：</p>
<pre><code>public RequestQueue(Cache cache, Network network) {
    //调用三个参数的构造方法
    this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);
}
</code></pre><p>DEFAULT_NETWORK_THREAD_POOL_SIZE是声明的常量=4，所以我们知道Volley的网络请求线程数量默认为4个。上述构造方法调用了四个参数的构造方法：</p>
<pre><code> public RequestQueue(Cache cache, Network network, int threadPoolSize) {
    //调用四个参数对的构造方法
    this(cache, network, threadPoolSize,
            new ExecutorDelivery(new Handler(Looper.getMainLooper())));
}
</code></pre><p><strong>注意以上方法的最后一个参数，这是一个绑定了主线程handler的ExecutorDelivery对象，用处在后文进行说明</strong><br>四个参数的构造方法的实现：</p>
<pre><code>    public RequestQueue(Cache cache, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache = cache;
    mNetwork = network;
    mDispatchers = new NetworkDispatcher[threadPoolSize];
    mDelivery = delivery;
}
</code></pre><p>这样requestqueue就创建完成，</p>
<h3 id="2-网络请求的执行"><a href="#2-网络请求的执行" class="headerlink" title="2.网络请求的执行"></a>2.网络请求的执行</h3><p>创建的requestqueue.queue.start()方法在创建的最后一行得到了调用。<br>queue.start()的具体实现：</p>
<pre><code> public void start() {
    stop();  // 确保现有的dispatcher停止工作
    // 创建cacheDispatcher并启动
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    //根据线程池(mDispatchers)的大小创建网络请求线程。
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        //按创建顺序启动对应的线程
        networkDispatcher.start();
    }
}
</code></pre><p>正如代码的注释一样，先创建并启动缓存线程用来读取缓存内容，再创建网络请求线程用于网络请求。mDispatchers为线程数组，默认大小为4，networkDispatcher网络请求执行线程。<br>我们重点分析一下网络请求线程的创建：</p>
<pre><code>NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,mCache, mDelivery);
</code></pre><p><strong>我们着重关注一下mDelivery对象，它是一个绑定了主线程handler的ExecutorDelivery对象</strong></p>
<p>由于NetworkDispatcher本身是一个线程，调用start()方式实际会执行它的run()方法，我们来到run()方法内部：</p>
<pre><code>@Override
public void run() {
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    while (true) {
        long startTimeMs = SystemClock.elapsedRealtime();
        Request&lt;?&gt; request;
        try {
               //从请求队列中取出网络请求
            request = mQueue.take();
        } catch (InterruptedException e) {
            // We may have been interrupted because it was time to quit.
            if (mQuit) {
                return;
            }
            continue;
        }

        try {
            request.addMarker(&quot;network-queue-take&quot;);
            //判断请求是否取消，取消则不执行该请求
            if (request.isCanceled()) {
                request.finish(&quot;network-discard-cancelled&quot;);
                continue;
            }

            addTrafficStatsTag(request);

            // 发送网络请求
            NetworkResponse networkResponse = mNetwork.performRequest(request);
            ...
             // 在子线程解析返回结果
            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
               ...
            省略的代码用于请求成功的结果进行缓存
            ...
            //将请求的结果发送出去
            mDelivery.postResponse(request, response);
        } catch (VolleyError volleyError) {
            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
            parseAndDeliverNetworkError(request, volleyError);
        } catch (Exception e) {
            VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
            VolleyError volleyError = new VolleyError(e);
            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
            mDelivery.postError(request, volleyError);
        }
    }
}
</code></pre><p>代码比较多，由于主要研究网络请求部分，上述代码的请求结果缓存部分我进行了省略，你可以自行查看源码。<br>上述代码的核心在于以下三个方法：</p>
<pre><code>mNetwork.performRequest()
Response&lt;?&gt; response = request.parseNetworkResponse()
mDelivery.postResponse(request, response);
</code></pre><p>避免代码过多我就不贴源代码了，作用：</p>
<ul>
<li>mNetwork.performRequest()——最终调用HurlStack().performRequest()方法采用httpUrlConnection的方式进行网络请求。</li>
<li>request.parseNetworkResponse()——根据parseNetworkResponse()的具体逻辑实现在子线程对结果进行解析(<strong>这也是自定义Request需要实现的方法之一，比如需要返回javaBean就需要该方法中进行解析</strong>)</li>
<li>mDelivery.postResponse(request, response)——将解析结果分发到<strong>主线程</strong></li>
</ul>
<h3 id="3-Response的分发"><a href="#3-Response的分发" class="headerlink" title="3.Response的分发"></a>3.Response的分发</h3><p>最后我们来看看Response的分发。<br>mDelivery是一个ExecutorDelivery对象，内部存在一个成员对象叫做mResponsePoster(为Executor类型)，最终调用这个mResponsePoster.execute()方法对response进行分发。<br>具体过程如下：<br>mDelivery.postResponse(request, response)方法怎么把结果分发到主线程：<br>该方法实现如下，调用了重载的postResponse(request, response, null)方法：</p>
<pre><code>  public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) {
    postResponse(request, response, null);
}
</code></pre><p>源码如下：</p>
<pre><code> public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) {
    request.markDelivered();
    request.addMarker(&quot;post-response&quot;);
    //执行分发
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
</code></pre><p> mResponsePoster也是一个Executor对象，通过execute()方法来执行Runnable对象的run()方法：它的execute()方法实现如下：</p>
<pre><code>public ExecutorDelivery(final Handler handler) {
    // 采用handler.post()方法将runnable对象运行在主线程
    mResponsePoster = new Executor() {
        @Override
        public void execute(Runnable command) {
            handler.post(command);
        }
    };
}
</code></pre><p><strong>可以看到这里使用了handler.post()来使得runnable对象运行在与该handler所绑定的线程中</strong><br>那么这个handler是在哪里赋值的呢？<br>往上翻，那就是在前文中两次注明的mDelivery对象，它是一个绑定了主线程handler的ExecutorDelivery对象，所以这里的handler是和主线程绑定的，在分发response的时候，我们的回调方法最终会运行在主线程。<br>ResponseDeliveryRunnable类的run()方法部分代码实现如下：</p>
<pre><code>   // 分发请求结果或者错误消息
if (mResponse.isSuccess()) {
    mRequest.deliverResponse(mResponse.result);
} else {
    mRequest.deliverError(mResponse.error);
}
</code></pre><p>deliverResponse(mResponse.result)也是在自定义Request的时候可以覆盖的方法。在Volley自带的StringRequest类中，该方法实现如下：</p>
<pre><code>    @Override
protected void deliverResponse(String response) {
    mListener.onResponse(response);
}
</code></pre><p>这里就调用了我们在使用Volley创建StringRequest对象时设置的监听器的onResponse(reponse)方法。然后就可以在改方法中更新UI了。</p>
<h2 id="Volley用到线程池了吗？"><a href="#Volley用到线程池了吗？" class="headerlink" title="Volley用到线程池了吗？"></a>Volley用到线程池了吗？</h2><p>直观地看来，Volley是没有用到线程池的，它采用的是一个默认长度为4的线程数组(名为mDispatcher)，在具体的网络请求线程(networkDispatcher)的run()方法中，Volley采用了如下的结构：</p>
<pre><code>public void run(){
    while(true){
    //从请求队列中取出请求
    requestQueue.take();
    ...
    }
}
</code></pre><p>这个死循环使得run()方法永远不会结束，对应的线程也就不会被销毁，而当requestQueue.take()没有获取到请求的时候(即请求队列已空)，该线程就会被阻塞而暂时停止运行。有新的请求的时候又得到运行进而发送新的网络请求。<br>可以发现，Volley没有使用线程池来管理网络请求线程，而是采用死循环的方式来避免了不断地创建、销毁线程带来的开销，达到了和线程池同样的效果。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里只是简单梳理了一遍Volley的网络请求流程，对缓存部分没有作讲解，若想了解更多，还请读者自行查看源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Volley简介&quot;&gt;&lt;a href=&quot;#Volley简介&quot; class=&quot;headerlink&quot; title=&quot;Volley简介&quot;&gt;&lt;/a&gt;Volley简介&lt;/h2&gt;&lt;p&gt;众所周知，Volley是google在2013年开源的一款异步异步异步http网络请求库，采用Volley进行网络请求非常简单。那么怎样个异步法？最简单的解释就是：&lt;br&gt;使用Volley你不用再像原生的HttpUrlConnection一样new Thread(new runable());新开工作线程这些事Volley都帮你做了。&lt;br&gt;Volley为http请求提供了如下的保障：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="volley" scheme="http://yoursite.com/tags/volley/"/>
    
  </entry>
  
  <entry>
    <title>自定义view和viewgroup</title>
    <link href="http://yoursite.com/2017/02/20/%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%92%8Cviewgroup/"/>
    <id>http://yoursite.com/2017/02/20/自定义view和viewgroup/</id>
    <published>2017-02-20T13:14:28.000Z</published>
    <updated>2017-02-22T15:17:01.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的上一篇博客对view的绘制过程作了介绍，那么接下来当然是创造自己的view，为了方便描述，下文依然将使用view代表不能包含子内容的控件，用viewgroup代表容器，但是实际上viewgroup也是view（ViewGroup类继承自View类）。由于最近才开始正式探索view方面的知识，所以这几篇文章也是对我学习view的一个记录吧，知识参考自View和ViewGroup源码以及《Android群英传》</p>
<h2 id="View类的重要方法"><a href="#View类的重要方法" class="headerlink" title="View类的重要方法"></a>View类的重要方法</h2><a id="more"></a>
<p>这里介绍的是继承View类或者ViewGroup类进行自定义，组合控件以及继承现有控件不涉及。<br>首先明确：<br>在前一篇文章view的绘制中提到的<br>measure()、onMeasure()<br>layout()、onLayout()<br>draw()、dispatchDraw()、onDraw() 这些方法全都是View类中声明的方法，其中measure()方法为final类型不可覆盖。  </p>
<h3 id="1-自定义view简介"><a href="#1-自定义view简介" class="headerlink" title="1.自定义view简介"></a>1.自定义view简介</h3><p>自定义view需要继承View类，并且覆盖onMeasure()（以便支持wrap_content属性）、onDraw()，因为view的位置实际是在layout()方法中通过setframe()方法进行设置的，而layout()在View类声明的时候已经实现这一操作，所以自定义view不必修改layout(),也一般不必覆盖onLayout()方法。</p>
<h3 id="2-自定义viewgroup简介"><a href="#2-自定义viewgroup简介" class="headerlink" title="2.自定义viewgroup简介"></a>2.自定义viewgroup简介</h3><p>ViewGroup类继承自View类并且将onLayout()方法覆盖声明为abstract，所以自定义viewgroup必须实现该方法，由于viewgroup的位置也已经在layout()中设置完毕，所以onLayout()方法的唯一作用就是遍历子view并调用子view的layout()方法来布局子view。同自定义view一样，要想支持wrap_content属性，就必须覆盖onMeasure()方法,而ViewGroup类的onMeasure()只负责测量自身（仅仅使自己充满父布局），所以必须重写来重新测量自身和包含的子view。</p>
<h2 id="谁来决定view的大小？"><a href="#谁来决定view的大小？" class="headerlink" title="谁来决定view的大小？"></a>谁来决定view的大小？</h2><p>view的大小最终是由自身决定的，而外层的viewgroup只是获取该view的xml属性，并且根据该属性进行大小的具体赋值，比如：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
     android:orientation=&quot;vertical&quot;
     tools:context=&quot;com.distancelin.demo.MainActivity&quot;&gt;
   &lt;Button
        android:layout_width=&quot;wrap_content&quot;
     android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>在LinearLayout的onMeasure()方法中，会获取到Button中所定义的两个wrap_content属性，对应了MeasureSpec.AT_MOST情况，但是LinearLayout只知道这个Button的mode是MeasureSpec.AT_MOST，并不知道具体的数值应该是多大，所以LinearLayout就会通过具体的逻辑对具体大小赋值：并且将赋值之后的数值连同Button的mode一起封装在MeasureSpec对象中传递给Button的measure()方法。这就是measure()方法中两个参数的来源。<br>ViewGroup类中的measureChild()方法就是这一过程的最简单实现：</p>
<pre><code> protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    //获取子view布局参数
    final LayoutParams lp = child.getLayoutParams();
    //对子view的具体大小赋值
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);
    //通过measure()将大小传递给子view
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
</code></pre><p>而measure()方法最终又将这两个参数传递给了自己的onMeasure()方法，在这里就可以根据自己的逻辑重新设置需要的大小。<br>其中getChildMeasureSpec()就是根据自己的大小，分情况对子view的大小进行赋值：</p>
<pre><code> public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);

    int size = Math.max(0, specSize - padding);

    int resultSize = 0;
    int resultMode = 0;

    switch (specMode) {
    // Parent has imposed an exact size on us
    case MeasureSpec.EXACTLY:
        if (childDimension &gt;= 0) {
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size. So be it.
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can&apos;t be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent has imposed a maximum size on us
    case MeasureSpec.AT_MOST:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... so be it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size, but our size is not fixed.
            // Constrain child to not be bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can&apos;t be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent asked to see how big we want to be
    case MeasureSpec.UNSPECIFIED:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... let him have it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size... find out how big it should
            // be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size.... find out how
            // big it should be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
        break;
    }
    //noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
</code></pre><p>可以看到，不管是view还是viewgroup的大小，最终都是在自己的onMeasure()方法中决定的，他们的父视图只负责获取view或者viewgroup的xml属性并根据属性对大小进行赋值，最终传递给子view的onMeasure()方法。<br><strong>所以我是这样理解的，一个view的大小是在父viewgroup的控制之下，由自己在onMeasure()中调用setMeasuredDimension()最终确定的。</strong></p>
<h2 id="谁决定了view的位置？"><a href="#谁决定了view的位置？" class="headerlink" title="谁决定了view的位置？"></a>谁决定了view的位置？</h2><p>和大小同理<br>view的位置同样是是在父viewgroup的控制之下，由自己在layout(int left,int top,int right,int bottom)中调用setFrame()最终确定的。ViewGroup.onLayout()用来布局子view，View.onLayout()方法实现为空。</p>
<h2 id="实践——自定义viewgroup"><a href="#实践——自定义viewgroup" class="headerlink" title="实践——自定义viewgroup"></a>实践——自定义viewgroup</h2><p>根据书中描述的过程  </p>
<p>实现类似照片浏览的功能，滑动显示每个视图，并根据滑动的距离来决定是否进入下一个视图</p>
<pre><code>public class ScreenScrollView extends ViewGroup {
    private int mScreenHeight;
    private int mScreenWidth;
    private int mLastY;
    private Scroller mScroller;
    private int mStart;

    public ScreenScrollView(Context context) {
        this(context, null);
    }

    public ScreenScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mScroller = new Scroller(context);
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        mScreenHeight = wm.getDefaultDisplay().getHeight();
        mScreenWidth = wm.getDefaultDisplay().getWidth();
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        int childCount = getChildCount();
        for (int i = 0; i &lt; childCount; i++) {
            View childView = getChildAt(i);
            if (childView.getVisibility() != View.GONE) {
                childView.layout(1, i * mScreenHeight, mScreenWidth-1, (i + 1) * mScreenHeight);
            }
        }
    }


    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //super.onMeasure()使得该viewGroup充满父布局
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int childCount = getChildCount();
        LayoutParams mlp = getLayoutParams();
        mlp.height = mScreenHeight * childCount;
        setLayoutParams(mlp);
        for (int i = 0; i &lt; childCount; i++) {
            View childView = getChildAt(i);
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int y = (int) event.getY();
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mLastY = y;
                mStart=getScrollY();
                break;
            case MotionEvent.ACTION_MOVE:
                int dy = mLastY - y;
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
               /* getScrollY()返回相对自己的初始位置的偏移量，计算方法为初始Y-nowY,
               *   当已经滑到顶端并且继续往下滑*/
                if (getScrollY() &lt; 0 &amp;&amp; dy &lt; 0) {
                    dy = 0;
                }
                //内容滑到底端且手指继续往上滑
                if (getScrollY() &gt; (getHeight() - mScreenHeight) &amp;&amp; dy &gt; 0) {
                    dy = 0;
                }
                scrollBy(0, dy);
                mLastY = y;
                break;
            case MotionEvent.ACTION_UP:
                //手指往上滑时，值为负；反之为正
                int end=getScrollY();
                int scrollY=end-mStart;
                //手指往上滑
                if(scrollY&lt;0){
                    if((-scrollY)&gt;(mScreenHeight/8)){
                        mScroller.startScroll(0,getScrollY(),0,-mScreenHeight-scrollY);
                    }
                    else {
                        mScroller.startScroll(0,getScrollY(),0,-scrollY);
                    }
                }
                //手指往下滑
                else {
                    if(scrollY&gt;(mScreenHeight/8)){
                        mScroller.startScroll(0,getScrollY(),0,mScreenHeight-scrollY);
                    }
                    else {
                        mScroller.startScroll(0,getScrollY(),0,-scrollY);
                    }
                }
                break;
        }
        return true;
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        if (mScroller.computeScrollOffset()) {
            scrollTo(0, mScroller.getCurrY());
            postInvalidate();
        }
    }
}
</code></pre><p>一些小细节值得优化，大体效果如下：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-22/64787466-file_1487776525996_13c4d.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我的上一篇博客对view的绘制过程作了介绍，那么接下来当然是创造自己的view，为了方便描述，下文依然将使用view代表不能包含子内容的控件，用viewgroup代表容器，但是实际上viewgroup也是view（ViewGroup类继承自View类）。由于最近才开始正式探索view方面的知识，所以这几篇文章也是对我学习view的一个记录吧，知识参考自View和ViewGroup源码以及《Android群英传》&lt;/p&gt;
&lt;h2 id=&quot;View类的重要方法&quot;&gt;&lt;a href=&quot;#View类的重要方法&quot; class=&quot;headerlink&quot; title=&quot;View类的重要方法&quot;&gt;&lt;/a&gt;View类的重要方法&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="自定义view" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
  </entry>
  
  <entry>
    <title>view的绘制过程</title>
    <link href="http://yoursite.com/2017/02/19/View%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/19/View的绘制过程/</id>
    <published>2017-02-19T06:48:05.000Z</published>
    <updated>2017-05-11T11:16:53.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View和ViewGroup简介"><a href="#View和ViewGroup简介" class="headerlink" title="View和ViewGroup简介"></a>View和ViewGroup简介</h2><p>在安卓中，显示的视图可以分为两类，view和viewgroup，而view是所有控件的基类，viewgroup也是继承自view的，不同的是viewgroup可以容纳子view，而view不能再容纳任何子view。而我们平时在布局文件里使用的绝大多数控件，都是view类和viewgroup的子类。<br>viewgroup的子类：各种layout布局，比如linerlayout，framelayout，relativelayout等等。<br>view的子类：各种控件，比如textview，button等等。<br><a id="more"></a><br>这样以来，布局文件里的内容就形成了一棵树状结构，即我们经常谈起的view树：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-19/14968804-file_1487488155000_167a8.png" alt=""></p>
<p>为了方便描述，下文用view指代控件（不能包含子view），用viewgroup指代容器（可以包含子view）</p>
<h2 id="View的显示过程"><a href="#View的显示过程" class="headerlink" title="View的显示过程"></a>View的显示过程</h2><p>view的显示必须经过测量、布局和绘制三个阶段，分别对应onMeasure()、onLayout()和onDraw()三个回调方法。作用分别如下：<br>onMeasure()——经过测量初步确定view的宽和高（至于为什么是初步确定，后面再讲解）<br>onLayout()———根据onMeasure()中初步确定的宽高，对view进行布局即确定当前的view应该放在屏幕的哪个位置，（这一步有可能对初步确定的宽和高重新赋值）<br>onDraw()———调用绘图api(canvas.drawXX()方法)在该位置绘制view，至此，view便显示在屏幕上了</p>
<h3 id="1-view的测量"><a href="#1-view的测量" class="headerlink" title="1.view的测量"></a>1.view的测量</h3><p>首先需要明确一点，所有子view的测量都是在直接父viewgroup的控制下完成的，什么意思？比如现在有如下布局文件：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-19/11256864-file_1487495456959_5eac.png" alt=""><br>根布局linearlayout具有两个直接子view——framelayout和button，所以framelayout和button的测量是由linearlayout控制完成的，那么怎么控制并完成的呢？<br>首先，viewgroup自身的measure()方法被调用，在进行一些处理之后，measure()方法内部调用onMeasure()方法，onMeasure()方法循环遍历自己的直接子view，并且调用每个子view的<strong>measure()</strong>方法（不是onMeasrue()），FrameLayout中该方法部分实现如下：</p>
<pre><code>if (count &gt; 1) {
       for (int i = 0; i &lt; count; i++) {
           final View child = mMatchParentChildren.get(i);
           //获取子view在xml文件中设置的布局参数
           final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
           //根据子view的布局参数确定子view的width，不进行合法性检查
           final int childWidthMeasureSpec;
           if (lp.width == LayoutParams.MATCH_PARENT) {
               final int width = Math.max(0, getMeasuredWidth()
                       - getPaddingLeftWithForeground() - getPaddingRightWithForeground()
                       - lp.leftMargin - lp.rightMargin);
               childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(
                       width, MeasureSpec.EXACTLY);
           } else {
               childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                       getPaddingLeftWithForeground() + getPaddingRightWithForeground() +
                       lp.leftMargin + lp.rightMargin,
                       lp.width);
           }
           //根据子view的布局参数确定子view的height，不进行合法性检查
           final int childHeightMeasureSpec;
           if (lp.height == LayoutParams.MATCH_PARENT) {
               final int height = Math.max(0, getMeasuredHeight()
                       - getPaddingTopWithForeground() - getPaddingBottomWithForeground()
                       - lp.topMargin - lp.bottomMargin);
               childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                       height, MeasureSpec.EXACTLY);
           } else {
               childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,
                       getPaddingTopWithForeground() + getPaddingBottomWithForeground() +
                       lp.topMargin + lp.bottomMargin,
                       lp.height);
           }
           //调用子view的measure()方法
           child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
       }
   }
</code></pre><p>可以看到最终父viewgroup调用了每个直接子view的measure()方法，而为什么不是调用子view的onMeasure()方法呢？我理解的原因主要有两个：</p>
<ul>
<li>onMeasure()方法为protected类型，只能在子类内部访问，不能在外部访问。</li>
<li>measure()方法还会进行进一步的复杂处理，包括传入参数的优化等，执行这些代码之后，才会调用onMeasure()方法。</li>
</ul>
<p>这是view.measure()方法中调用onMeasure()的部分：</p>
<pre><code>if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {
           onMeasure(widthMeasureSpec, heightMeasureSpec);
           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
       } 
</code></pre><p>下面是View.onMeasure()的默认实现：</p>
<pre><code> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
</code></pre><p>通过 setMeasuredDimension方法设定该view的初步测量值。<br>最内层的getSuggestedMinimumWidth()将返回父view能容纳的最大值。<br>getDefaultSize方法用于返回默认的大小，实现如下：</p>
<pre><code> public static int getDefaultSize(int size, int measureSpec) {
    //将result赋值为父视图的最大值
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    //未确定的时候赋值为size
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    //wrap_content的时候不进行赋值操作，即默认为size的大小
    case MeasureSpec.AT_MOST:
    //指定为精确值
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}
</code></pre><p>分析以上方法的执行可以得出结论，默认的View.onMeasure()方法不支持wrap_content属性，即使在xml中指定为wrap_content也会默认设置为充满父view所以，在自定义view的时候，要想你的view支持wrap_content属性，必须覆盖view的onMeasure()方法并加入wrap_content的相关逻辑。<strong>view.measure为final方法，不能覆盖</strong></p>
<p>这样，view的测量阶段就完成了。</p>
<h3 id="view的布局"><a href="#view的布局" class="headerlink" title="view的布局"></a>view的布局</h3><p>同view的测量类似，这一阶段viewgroup自身的layout()方法被调用，确定自己的位置之后，layout()方法内部调用onlayout()，onLayout()调用layoutChildren()方法来对所有直接子view进行布局，FrameLayout中的具体实现：</p>
<pre><code>protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    layoutChildren(left, top, right, bottom, false );
}
</code></pre><p>layoutChildren()方法的部分实现：</p>
<pre><code>void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) {
    //获取直接子view数量
    final int count = getChildCount();
    此处代码有省略...
    for (int i = 0; i &lt; count; i++) {
        final View child = getChildAt(i);
        if (child.getVisibility() != GONE) {
            //获取子view在xml布局文件中定义的属性
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            此处代码省略...（省略的代码主要用于各种判断逻辑，用来确定布局位置）
            //调用子view的layout方法
            child.layout(childLeft, childTop, childLeft + width, childTop + height);
        }
    }
}
</code></pre><p>可以看到和测量过程类似，都是通过循环取得每一个子view，再获得子view在xml文件中定义的各种属性，加以判断，最后调用子view的对应方法，不同的是，测量过程更关心view的宽和高，所以主要判断大小相关的属性。而布局过程更关心view的位置，所以判断的属性大都是view的位置相关属性，比如centerinparent是否为true等等。<br>在view的layout()方法又会调用onLayout()方法：</p>
<pre><code>  public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

//调用setframe或者setOpticalFrame方法来设置该自己相对于父viewgroup的坐标(左上和右下)
    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        //调用子view的onLayout()方法
        onLayout(changed, l, t, r, b);
        ...
}
</code></pre><p>View类的onLayout()方法默认实现为空：</p>
<pre><code> protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
}
</code></pre><p>再来总结一下layout阶段的工作：</p>
<ol>
<li>父viewproup的layout方法被调用，首先调用setframe或者setOpticalFrame设置自己的位置，然后调用onLayout()方法循环遍历子view并调用子view.layout()</li>
<li>子view的layout()方法通过调用内部setframe或者setOpticalFrame方法来设置该view相对于父viewgroup的坐标</li>
<li>子view.layout()方法调用自己的onLayout()方法</li>
</ol>
<p><strong>由于view不能再包含子view，而且view的位置在view类内部的layout()方法中已经通过setframe或者setOpticalFrame确定，所以继承view类来自定义view的时候，一般不用覆盖onLayout()方法</strong><br>到此，view的位置也已经确定好了。</p>
<h3 id="view的绘制"><a href="#view的绘制" class="headerlink" title="view的绘制"></a>view的绘制</h3><p>这一阶段父viewproup调用子视图(可能是viewgroup也可能是view)的draw()方法，draw()方法在View类进行了实现，部分实现如下：</p>
<pre><code>public void draw(Canvas canvas) {
    ...
    /*
     * Draw traversal performs several drawing steps which must be executed
     * in the appropriate order:
     *
     *      1. Draw the background
     *      2. If necessary, save the canvas&apos; layers to prepare for fading
     *      3. Draw view&apos;s content
     *      4. Draw children
     *      5. If necessary, draw the fading edges and restore layers
     *      6. Draw decorations (scrollbars for instance)
     */
    ...
    if (!verticalEdges &amp;&amp; !horizontalEdges) {
        // 绘制自己
        if (!dirtyOpaque) onDraw(canvas);
        // 绘制子视图
        dispatchDraw(canvas);
        ...
}
</code></pre><p>可以看到draw()方法先调用自己的onDraw()方法绘制自己，然后调用 dispatchDraw(canvas)来遍历得到所有子视图（可能是viewgroup也可能是view）并调用子视图的draw()方法，draw()方法的关键实现已在上面代码中说明。<br>可以看到</p>
<ol>
<li>假如子视图是一个view，调用了子视图的onDraw()方法之后，dispantchDraw()虽然得到了调用，但是方法中不会再进行绘制子视图操作，因为view不可能在包含子视图。</li>
<li>假如子视图是viewgroup，若该viewgroup没有指定background属性，那么该viewgroup的OnDraw()方法不会被调用（由于if(!dirtyOpaque)），但是dispatchDraw()方法始终会被调用，因为viewgroup一般都包含有子视图。</li>
</ol>
<p>至此，view的绘制过程也结束了，view最终成为了我们看到的样子。</p>
<h2 id="view显示过程缩略概括"><a href="#view显示过程缩略概括" class="headerlink" title="view显示过程缩略概括"></a>view显示过程缩略概括</h2><ol>
<li>viewgroup和view的测量：<br>首先，最外层viewgroup的measure()方法得到调用，measure()方法进行了一些处理之后，其内部又调用了onMeasure()方法，在onMeasure()方法中除了进行自身的测量并调用setMeasuredDimension()设置自身大小之外，若该视图下包括了子视图，还要遍历调用所有子视图的measure()方法。<br>所以<strong>viewgroup的onMeasure()方法除了初步测量自身的大小，还要初步测量子view的大小，并调用子.view的measure()方法传入初步测量的高和宽，由子view的onMeasure()方法再次确定合适的大小</strong></li>
<li>viewgroup和view的布局：<br>最外层viewgroup的layout()被调用，该方法设置了自己的位置之后，调用自身onLayout()遍历所有子视图并调用子视图的layout()方法。<br><strong>ViewGroup类的onLayout()方法是抽象方法，自定义viewgroup时必须实现，而View类的onLayout()方法默认实现为空</strong></li>
<li>viewgroup和view的绘制<br>最外层viewgroup的draw()被调用，viewgroup若没有设置background属性则不会执行自己的onDraw(),继续执行dispatchDraw()遍历绘制所有子view。</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol>
<li><p>既然measure、layout和draw都是从最外层viewgroup开始的，那么是谁调用了最外层viewgroup的measure()、layout()和draw()方法呢？<br>答案是viewRoot的performTraversals()方法:</p>
<pre><code>private void performTraversals() {

    ............
    //获得view宽高的测量规格，mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高
     int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
     int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);

      // Ask host how big it wants to be
      //执行测量操作
      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);

    ........................
    //执行布局操作
     performLayout(lp, desiredWindowWidth, desiredWindowHeight);

    .......................
    //执行绘制操作
    performDraw();

}
</code></pre><p>这里给出一张安卓UI的架构图：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-20/53794475-file_1487521830801_9ac.png" alt=""><br>至于Activity,Window,DecorView 和 ViewRoot 的关系和职责，可以参考以下链接：<br><a href="https://gold.xitu.io/entry/571338c7c4c9710054cea455" target="_blank" rel="external">点我点我</a></p>
</li>
<li>view.getMeasuredWidth()和view.getWidth()的区别<br>view.getMeasuredWidth()——获得在onMeasure()方法中调用setMeasuredDimension()之后的view宽度,执行setMeasuredDimension()之后mMeasuredWidth才被赋值，进而onLayout阶段可以调用getMeasuredWidth()获得初步测量的宽度</li>
</ol>
<ul>
<li>view.getWidth()——获得在onLayout()方法之后的view宽度<br><strong>在重写了onLayout方法之后，二者的返回值视重写的逻辑而定有可能不同，比如某个view在xml中指定宽度为1000dp,那么测量阶段的值就是1000dp，而假如你在layout()里加入判断认为该值过大，然后在该方法中向的setframe()传递了一个新的宽度值，getWidth()方法就将返回该值，这只是举的特殊情况，大多数情况下二者还是一样的</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View和ViewGroup简介&quot;&gt;&lt;a href=&quot;#View和ViewGroup简介&quot; class=&quot;headerlink&quot; title=&quot;View和ViewGroup简介&quot;&gt;&lt;/a&gt;View和ViewGroup简介&lt;/h2&gt;&lt;p&gt;在安卓中，显示的视图可以分为两类，view和viewgroup，而view是所有控件的基类，viewgroup也是继承自view的，不同的是viewgroup可以容纳子view，而view不能再容纳任何子view。而我们平时在布局文件里使用的绝大多数控件，都是view类和viewgroup的子类。&lt;br&gt;viewgroup的子类：各种layout布局，比如linerlayout，framelayout，relativelayout等等。&lt;br&gt;view的子类：各种控件，比如textview，button等等。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="view绘制" scheme="http://yoursite.com/tags/view%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio修改Gradle版本</title>
    <link href="http://yoursite.com/2017/02/01/Android-Studio%E4%BF%AE%E6%94%B9Gradle%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2017/02/01/Android-Studio修改Gradle版本/</id>
    <published>2017-01-31T16:53:58.000Z</published>
    <updated>2017-01-31T19:18:58.532Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新下载安装了AS，发现对gradle的配置有些忘记了，写下这篇博客做个记录。</p>
<h2 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h2><p>下载的android studio分为自带SDK（.exe）和不带SDK（.zip）两种版本，如下图所示：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-1/59502089-file_1485886380496_171d8.png" alt=""><br><a id="more"></a><br>自带sdk版本安装之后会让你选择sdk的安装位置，而不带sdk版本解压之后第一次运行会下载sdk，默认位置为C:\Users\username\AppData\Local\Android\sdk，在AS里可以修改其位置。<br>至于gradle，AS里是自带一个版本的gradle的(具体版本视AS版本而定)，如图:<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-1/4031187-file_1485886838343_11c7b.png" alt=""><br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-1/58065160-file_1485886838475_16e3f.png" alt=""><br>如果以前没有修改过的话，在C:\Users\username.gradle下也有gradle，内容如下：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-1/11271820-file_1485887210610_152ee.png" alt=""><br>，两者的区别在后面进行讲解。</p>
<h2 id="AS的gradle路径指定"><a href="#AS的gradle路径指定" class="headerlink" title="AS的gradle路径指定"></a>AS的gradle路径指定</h2><p>在AS里选择file-&gt;settings-&gt;搜索gradle：<br><img src="http://ohvhuumh1.bkt.clouddn.com/17-2-1/26094548-file_1485887594214_1831a.png" alt=""><br>在这里可指定gradle路径。<br>use default gradle wrapper————使用global gradle settings路径所指定的的gradle。<br>use local gradle distribution————使用gradle home中指定的gradle(与global中指定的目录无关)。<br>两者都是正确的配置方法，但是对应的gradle目录有所不同。<br>就我而言，wrapper方式的gradle目录路径为：<br>D:\android\gradle\wrapper\dists\gradle-2.14.1-all\8bnwg5hd3w55iofp58khbp6yv\gradle-2.14.1<br>而选择local distribution的路径为：<br>D:\android\android-studio\gradle\gradle-3.2<br>可以看到前者的目录路径中多了wrapper等目录，这是由AS生成的。</p>
<h2 id="修改gradle版本"><a href="#修改gradle版本" class="headerlink" title="修改gradle版本"></a>修改gradle版本</h2><p>如果在AS内自动下载gradle的话可能比较慢，这时需要自己下载gradle的各个版本进行版本修改。<br><a href="http://services.gradle.org/distributions/" target="_blank" rel="external">gradle各版本下载地址</a><br>修改的方式有两种：</p>
<ul>
<li>将下载的gradle压缩包解压到某个目录，在AS里选择use local distribution，并将路径指定为该目录。</li>
<li>将gradle压缩包放在wrapper\dists\gradle-2.14.1-all\8bnwg5hd3w55iofp58khbp6yv\目录下(路径中的一长串字母是AS生成，各有不同)，在AS中指定use default gradle wrapper,并指定global gradle setting路径为wrapper目录的上一级目录，最后sync gradle就完成了，当然你可以放置多个版本的gradle压缩包来安装多个版本的gradle，在项目sync的时候会自动搜寻匹配的版本。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新下载安装了AS，发现对gradle的配置有些忘记了，写下这篇博客做个记录。&lt;/p&gt;
&lt;h2 id=&quot;相关介绍&quot;&gt;&lt;a href=&quot;#相关介绍&quot; class=&quot;headerlink&quot; title=&quot;相关介绍&quot;&gt;&lt;/a&gt;相关介绍&lt;/h2&gt;&lt;p&gt;下载的android studio分为自带SDK（.exe）和不带SDK（.zip）两种版本，如下图所示：&lt;br&gt;&lt;img src=&quot;http://ohvhuumh1.bkt.clouddn.com/17-2-1/59502089-file_1485886380496_171d8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="修改gradle版本" scheme="http://yoursite.com/tags/%E4%BF%AE%E6%94%B9gradle%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
</feed>
