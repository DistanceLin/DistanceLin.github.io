<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《图解http》笔记]]></title>
      <url>%2F2018%2F01%2F13%2F%E3%80%8A%E5%9B%BE%E8%A7%A3http%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[body和header之间以回车换行符分割，即CR+LF请求和响应报文： 一、首部字段（Http/1.1）1.常用通用首部字段 首部字段名 作用 Cache-Control 控制缓存行为 Connection 管理连接 Date 报文创建的日期时间 Pragma 报文指令 Transfer-Encoding 指定报文主题的传输编码方式 Upgrade 升级为其他协议 Cache-Control字段出现在请求和响应报文中又有不同的意义，在请求首部中: 指令 参数 作用 no-cache 无 强制向服务器请求数据 only-if-cached 无 从缓存获取数据 max-age=[秒] 必需 响应数据的有效期 max-stale=[秒] 可省略 数据过期之后仍然可用的时间 在响应首部中： 指令 参数 作用 public 无 可以向任何用户提供该缓存数据 private 无 只向特定用户提供该缓存数据 max-age=[秒] 必需 响应数据有效期 2.常用请求首部字段 首部字段名 作用 Accept 客户端可处理的媒体类型 Accept-Charset 优先字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先语言（自然语言） Host 所请求的资源所在服务器 If-Modified-Since 比较资源的更新时间 If-Match 比较实体标记（ETag） Range 实体的字节范围请求 User-Agent Http客户端程序信息 3.常用响应首部字段 首部字段名 作用 Server Http服务器的安装信息 Accept-Ranges 是否接受字节范围请求 ETag 实体标记信息 Location 令客户端重定向到指定URI Retry-After 对再次发起请求的时机要求 4.常用实体首部字段 首部字段名 作用 Expires 实体过期的日期时间 Last-Modified 资源的最后修改时间 Allow 资源可支持的Http方法 Content-Type 实体的媒体类型 Content-Length 实体的大小（单位：字节） Content-Range 实体的字节范围 Content-Language 实体的自然语言 除了以上Http/1.1中列出的常用字段之外，以下字段在通信中也很常用，如：Cookie、Set-Cookie. 二、首部和缓存控制安卓中网络请求都会涉及到缓存的考虑，比如okhttp就涉及了缓存策略。 Http版本 缓存相关字段 1.1之前 Prama、Expires、Last-Modified、If-Modify-Since 1.1 Cache-Control、Etag、If-None-Match 1.1中的缓存控制字段优先级都高于旧版本的字段、Cache-Control/Expires的优先级高于Last-Modified/ETag。在这些字段的作用下，一次请求的工作流程如下： 若在强制刷新的场景下（比如安卓下拉刷新了），就不应该再执行第一个判断而是应该直接发起网络条件请求 在电脑端浏览器刷新的时候，F5和Ctr+F5也存在重要的区别：ctr+F5直接连条件请求也跳过了。 三、Http的常用请求方法 方法 描述 GET 请求指定页面，并返回实体body HEAD 类似Get，但不返回实体 POST 向服务器提交数据（表单或上传文件） PUT 从客户端向服务器传送的数据取代服务器上的指定数据 DELETE 请求服务器删除指定页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 GET和POST的区别 GET请求可以被缓存，POST不能 GET请求提交参数时参数直接显示在URL上，以?链接以&amp;分割多个参数，而POST请求将参数置于请求实体中，更加安全 由于URL会有长度限制，所以GET请求会受到长度限制，POST请求理论上不会。 四、HTTP状态码状态码分为五类： 分类 描述 1xx 服务器收到请求，需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 重定向，需要进一步的操作完成请求 4xx 客户端错误，请求包含语法错误 5xx 服务器错误，服务器在处理请求过程中发生了错误 常见的状态码： 状态码 描述字段 中文描述 200 OK 请求成功，一般用于GET和POST 204 No Content 无内容，服务器成功处理但未返回内容，在未更新网页的情况，可确保浏览器继续显示当前文档 206 Partial Content 部分内容，服务器成功处理了范围GET请求 301 Moved Permanently 永久移动，请求的资源已被永久移动到新URI（Location字段），浏览器会自动定向到新URI，今后任何新的请求都应使用新URI 302 Found 临时移动，与301类似，但资源只是临时被移动。客户端应继续使用原有URI 304 Not Modified 未修改，用于条件GET请求 400 Forbidden 服务器理解客户端请求，但是拒绝执行 404 Not Found 请求的资源不存在 500 Internal Server Error 服务器内部错误，无法完成请求 505 HTTP version not supported 服务器不支持请求的Http协议版本 五、HttpsHttps即运行于SSL之上的Http协议，SSL提供加密、认证以及完整性三种技术来保证Http的安全通信。 认证SSL提供客户端认证（可选）服务器认证（必须），客户端首先会通过SSL握手来确认服务器的真实性，这一阶段服务器会把自己的密钥证书（由CA颁发并签名）发送给客户端，客户端用CA公钥（一般内置到了浏览器中）来验证该证书是否是由正规CA颁发，并且从中获取到服务器的公钥。 加密SSL中同时使用对称加密和非对称加密，在传递密钥的时候，采用非对称加密，一旦客户端和服务器完成密钥协商之后，后期的通信就采用协商的密钥进行对称加密。因为对称加密比非对称加密的效率更高，而非对称加密比对称加密更加安全。这样既保证安全性又保证了通信的效率。 报文完整性使用Https发送数据时会附加一种叫做MAC（Message Authenticaiton Code）的报文摘要，和MD5、SHA-1作用相同，一旦报文被改变就能够通过摘要的值对比发现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GestureDetector与view的旋转]]></title>
      <url>%2F2017%2F11%2F07%2FGestureDetector%E4%B8%8Eview%E7%9A%84%E6%97%8B%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[自定义view除了在onTouchEvent里处理交互之外，还可以使用GestureDetector来接管用户的手势操作，将手势转接给GestureDector来处理，其中内置了许多手势的监听，比如滑动、双击等事件。这里记录下使用GestureDetector来实现view跟随手指旋转的思路。核心的思路是监听手指在view上的滑动，根据手指滑动的方向来决定view应该顺时针还是逆时针旋转，至于单纯的旋转的话可以直接使用view的setRotation()传入角度，旋转角度的确定可大可小，在效果上看起来只是旋转灵敏度的差异，所以关键是旋转方向的判断。 旋转方向的判断view在屏幕上占据的始终是一块矩形区域，为了方便表述，在view里面画了一个圆：如图，在某一时刻，如果手指在屏幕上按照上图红线里滑动了一段距离，很明显这时候view应该顺时针旋转，下面推导如何得出顺时针旋转这个结论: 连接滑动手势的终点和view的中心点 2.作出1中线段的垂线 这样看起来还是不够明显，继续将三条线平移到下图的位置：这样就很清晰了，其实那条垂线就相当于作了一条圆的切线，通过判断手指滑动方向与圆切线方向的夹角，就能够得出，view应该向哪边旋转了。从图中可以看到，判断夹角的时候需要首先确定以切线的顺时针还是逆时针为基准，这里就以切线顺时针为基准，那判断方式就应该是： . 手指滑动方向与切线方向夹角&lt;90度，顺时针旋转 . 手指滑动方向与切线方向夹角&gt;90度，逆时针旋转 计算两条有方向的线之间的夹角，那自然就需要用到数学里向量的概念了。手指滑动(图中红线)作为向量a,顺时针切线(图中黄线)作为向量b。根据向量的数量积公式a b =|a| |b| * cosAOB.可见只需要根据数量积的正负，就可以判断夹角是钝角还是锐角了。 GestureDetector的onScroll()GestureDetector中的onScroll()封装了手指滑动的四个参数，官方的对参数的解释如下： 手指按下时触发ACTION_DOWN的MotionEvent。 手指在屏幕上滑动期间触发ACTION_MOVE的MotionEvent 剩下两个参数在实验中的结果如下： 因为在滑动过程中，onScroll()会多次调用，每次调用都会有新的MotionEvent，因为ACTIOON_MOVE在不断触发，打印前后两次MotionEvent的x、y坐标以及对应的distanceX和distanceY参数，根据上图可以分析得出onScroll()里的后两个参数分别为： distanceX——上一次滑动event的x减去本次滑动event的x坐标 distanceY——上一次滑动event的y减去本次滑动event的y坐标 那就等价于起点坐标减去了终点坐标，那自然而然向量a(distanceX,distanceY)，就对应了我们所需要的a向量了。已知了半径所在的向量，求切线所在的向量就很容易了，因为二者相互垂直，根据垂向量的特性，假设半径所在向量为(x,y)，那么切线所在向量就可以是(y,-x)或者(-y,x)，对应到图中，向量2(x,y)，向量3就应该是(y,-x)，因为view的坐标轴正方向为右和下，明显图里的2向量x&gt;0,y&gt;0；所以不难得出，3向量的横坐标&gt;0,纵坐标&lt;0，所以应该是(y,-x)。有了这个结论，就只需要求出2向量就可以得出我们所需要的b向量，也就是3. 根据onScroll()的参数不难得到，2向量的计算方法： @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { float x,y,vectorX,vectorY,rotationDerection; x=e2.getX(); y=e2.getY(); vectorX = x - mRectBounds.centerX(); vectorY = y - mRectBounds.centerY(); rotationDerection = calDotProduct(distanceX,distanceY,vectorX,vectorY); double rotateDegree = calRotateDegree(e1,e2); setRotation((float) (getRotation() +rotationDerection * rotateDegree)); return true; } e2对应每次的ACTION_MOVE，起点坐标-终点坐标就得到了2向量(vectorX,vectorY),所以b向量就等于(vectorY,-vectorX)。到此 a=(distanceX,distanceY) b=(vectorY,-vectorX) 可以求得数量积，进而得到旋转方向了。 private float calDotProduct(float distanceX, float distanceY, float vectorX, float vectorY) { float verticalX,verticalY; verticalX = vectorY; verticalY = -vectorX; float sign = distanceX * verticalX + distanceY * verticalY; return Math.signum(sign); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解计算机系统思维导图]]></title>
      <url>%2F2017%2F10%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[初步阅读了《深入理解计算机系统》，根据自己的情况，将内容和收获总结为以下导图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DCL的简单分析]]></title>
      <url>%2F2017%2F10%2F20%2FDCL%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[DCL是单例模式的懒汉式实现方式之一，全称为Double Check Lock，和饿汉式单例实现相比，它的单例对象实例化是在第一次调用获取单例的时候。与饿汉式单例模式一样，它也是线程安全的。很重要的一点就是关键字volatile的使用，下面从为什么volatile可以保证DCL的线程安全进行学习总结。 DCL中第二次判空的作用不使用volatile的DCL代码如下： public class SingleTon { public static SingleTon mInstance; //构造方法私有化 private SingleTon() { } public static SingleTon getInstance() { if (mInstance == null) { synchronized (SingleTon.class) { if (mInstance == null) { mInstance = new SingleTon(); } } } return mInstance; } } 第一次判空是为了避免不必要的同步，不用每次调用getInstance(）都进行同步。 第二次判空是为了在实例为空的时候创建对象 第二次判空必不可少，若在去掉第二层判空的情况下出现以下情况： 线程1执行完第一层判断之后，得到mInstance为空，cpu调度到线程2 线程2执行第一层判断，mInstance也为空，并执行同步块，完成了mInstance的实例化，此时mInstance已经不为空 cpu调度到线程1，从上次线程1中断的地方继续执行(第一层判空之后)，注意此在时线程1中判断的mInstance仍然为空，线程1继续执行实例化操作 这样mInstance被重复初始化了两次，而且两次的mInstance不是同一个实例。所以应该在同步块里进行第二层判空。 不使用volatile为什么会不安全？java中为引用赋值可以理解为三个步骤： mInstance=new SingleTon(); 分配内存空间 初始化对象 将内存空间的地址赋值给对应的引用 由于jvm的指令重排序，2、3两个步骤可能颠倒，若2、3被重排序，那么考虑如下情况： 线程1进行第一次判断为空，进入同步块，进行第二次判断，也为空，开始创建对象并赋值给mInstacne. JVM在堆上为对象分配空间 将对象的内存地址赋值给mInstance，那么此时mInstance已不等于null了 此时线程2执行了第一次判断(因为第一次判断不在syn块中，所以可以执行)，得到mInstance不为空，然后直接返回了mInstance，但此时mInstance所引用的对象还没有初始化，线程2直接使用的时候就会出现异常。 上述问题的原因是线程2拿到了单例对象的引用，但是对象却没有被初始化。根本原因是因为指令重排序问题，假如禁止了指令重排序，保证对象的初始化在引用赋值之前，那么只要线程2判断mInstance不为空，那么单例对象肯定已经完成了初始化。 禁止JVM指令重排序就可以采用volatile关键字，底层通过内存屏障实现。只需把mInstance声明为volatile类型。 public class SingleTon { public static volatile SingleTon mInstance; //构造方法私有化 private SingleTon() { } public static SingleTon getInstance() { if (mInstance == null) { synchronized (SingleTon.class) { if (mInstance == null) { mInstance = new SingleTon(); } } } return mInstance; } } 静态内部类实现单例因为静态内部类不会在外部类加载的时候被加载，而是在第一次调用getInstance()的时候才加载，这种方式既实现了懒汉式单例，又线程安全,关键是非常简洁： public class SingleTon { private SingleTon() { } public static SingleTon getInstance() { return SingletonHolder.mInstance; } static class SingletonHolder{ static final SingleTon mInstance=new SingleTon(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[隐式intent的匹配规则]]></title>
      <url>%2F2017%2F07%2F26%2F%E9%9A%90%E5%BC%8Fintent%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
      <content type="text"><![CDATA[隐式Intent通过隐式intent启动组件的时候，系统通过将该intent的内容与其他应用的AndroidManifest.xml中声明的Intent-filter进行比较，找到匹配的组件，并将该intent传递给组件，若有多个组件匹配，那么会提示用户选取某个应用。通过隐式intent来启动activity的匹配过程如下如所示：最终调用到了所匹配成功的Activity的onCreate()方法。隐式intent的匹配涉及了Intent中的三个信息，分别是： Action Category Data 这三个信息都可以在AndroidManifest文件中进行声明，典型的例子如下： &lt;activity android:name=&quot;ShareActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;text/plain&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 一个隐式intent的匹配就是根据Intent-filter中设置的这三个信息来找到对应的组件。下面分别是这三个信息的匹配过程。 1.action的匹配在声明一个intent对象的时候，可以通过构造方法来指定该intent对象的action属性，也可以通过setAction()方法来设置。action属性是String类型。系统中内置了许多action，这些action对应了Intent类中的一系列常量。比如Intent.ACTION_SEND常用于分享。隐式intent必须指定action属性。这一属性对应于Intent-filter中的 &lt;action android:name=“”/&gt; action属性为String类型，只有当隐式intent的action与Intent-filter中的某一个action完全一致的时候（Intent-filter中的action标签可以有多个），action才算匹配成功。 2.category的匹配通过addCategory()方法指定，同action标签一样，category标签在Intent-filter中也可以有多个，但是几乎所有的Intent-filter必须包含以下category标签（有一类特殊的category标签除外）： &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; startActivity() 和 startActivityForResult() 将按照已申明 CATEGORY_DEFAULT 类别的方式处理所有 Intent。 如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为你的 Activity。 在声明隐式intent用于启动activity时可以不调用addCategory（)来指定category，因为startActivity() 和 startActivityForResult()默认使用DEFAULT这个category。但是必须指定action。 3.data的匹配data由两个部分组成： mimeType URI 在Intent-filter中由data标签指定，格式如下： &lt;data android:scheme=&quot;string&quot; android:host=&quot;string&quot; android:port=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;string&quot;/&gt; 最后一项指定mimeType，前几项合起来指定了URI，URI的标准格式为：\://\:\/[\|\|\]，比如：file://abchttp://www.baidu.com可以通过以下三个方法来设置intent的Uri和mimeType： setData(Uri data) setType(String type) setDataAndType(Uri data,String type) setData()——设置intent的Uri，目标activity可以通过getIntent().getData()来获取传递的Uri。setTyoe()——设置intent的mimeType。setDataAndType()——同时设置Uri和mimeType。setData()和setType()会互相清除对方的值，所以要同时设置Uri和mimeType必须使用setDataAndType() 总结若隐式intent里同时设置了action、category、data，则这三者必须完全和intent-filter里声明的匹配规则相同才能匹配成功。反过来说，如果一个intent-filter里声明了action、category和data，那么要想和该intent-filter匹配，对应的intent里也必须设置这几项，缺一不可。 例子通过隐式intent分享特定内容： Intent intent=new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_TEXT,&quot;I&apos;m shared content&quot;); intent.setType(&quot;text/plain&quot;); //始终弹出选择界面，避免用户选择默认应用 Intent chooser=Intent.createChooser(intent,&quot;请选择应用&quot;) if(intent.resolveActivity(getPackageManager())!=null){ startActivity(chooser); } 调用浏览器浏览特定网页： Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); if(intent.resolveActivity(getPackageManager())!=null){ startActivity(intent); } intent里的data和extra都可以携带数据，在使用隐式intent启动activity的时候，有的activity接收extra携带\格式的数据(如上例一)，有的接收data携带的Uri形式的数据(如上例二)。 deep link从网页启动App除了从原生app中构建隐式intent来启动其他应用的组件之外，还可以从网页中启动原生app，实现的原理也基于intent-filter。下面是一个测试：在原生app的某个activity里，声明了如下的intent-filter： &lt;activity android:name=&quot;.Main2Activity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;!--这一行意味着满足wei://www.distancelin.cn*格式的链接都可以调启该组件--&gt; &lt;data android:host=&quot;www.distancelin.cn&quot; android:scheme=&quot;wei&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后在简书上用markdown写下了这样一篇文章，文章只包含了一个链接:测试文章发布之后，将该文章分享到qq，然后在qq里点击文章中的链接，就会发现调启了app中对应的activity，并且可以在activity里获取到通过链接传来的参数： Intent intent=getIntent(); Uri uri=intent.getData(); String site=uri.getQueryParameter(&quot;site&quot;); Log.i(&quot;H&quot;,site); 如果没安装该app，是不会有任何提示的，具体提示用户下载安装app的逻辑还需要进一步实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的征程——随手记]]></title>
      <url>%2F2017%2F07%2F16%2F%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B%E2%80%94%E2%80%94%E9%9A%8F%E6%89%8B%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[有一段时间没有更博了，前段时间的主要事情： 7月3日晚，完成了整个大学生涯的最后一门考试——《软件工程》 远行之前回家里和亲人们简单地团聚 7月10日，坐了一天两夜的火车，从重庆来到了深圳 这篇博客不记录任何技术上的知识，全是我离开大学这座象牙塔，离家几千里生活三天之后的所见所感。 关于校园至今我都很不情愿去接受我为期接近二十年的校园生涯就这样即将结束，即使大四下学期还会回到大学中去为整个校园生活画上一个句号——毕业设计。仔细想来，离开了学校这个地方，我们几乎没有任何机会能够每天这样规律、集体地坐在一个固定的地方去学习新的东西。上小学的时候，盼着能像初中生一样，可以每个星期在学校住；上初中的时候，盼着能像高中生一样，能够拥有自己的手机；上高中的时候，盼着能像大学生一样，可以那么自由，想逃课就逃课，考试不用削尖脑袋去考高分，及格就好；而身在大学里，又思考着快点毕业，去大城市闯荡。然而现在的我身在大城市，除了对今后的生活充满着激情和期待之外，我更怀念我的读书生涯。 关于生活孤身来到深圳，一切对我来说都相当陌生，如果非要说哪一点让我感到亲切的话，那应该是这里的路还有这里的天气，深圳的路平坦又宽阔，这一点和成都很相似；而这里的天气，太阳始终很毒，和重庆非常类似。在这座既陌生却带有熟悉气息的城市里，我拿着并不算高的实习工资，一切都必须精打细算，在这边许多东西都要重新买，伞、拖鞋、洗漱用品、被子。。。当面对着银行卡里并不多的预算和有限的工资，我真实地感觉到，生活，可能真的不是那么容易。以前在学校里，家里都会把足够的钱按时打到我的卡上，虽然算不上多，但是在衣食住行之后，也总有结余，而即将一个人在这边度过半年之久的我，真的应该好好地为他们想想。在这里的前两天，心里也是五味杂陈，由于刚到这边，路还不熟悉，手机也关机了不能导航，一路问加一路找才回到了住处，这两天里，一个人上下班，一个人逛超市，晚上回到家里也是空荡荡的(其他邻居还没入住)，可能人在这种环境下都会不自然地想家吧，开始感觉到亲人和家，才是永远最好的地方。现在想起来，在我很小的时候，爸爸每年就会出省打工，这样算下来，他已经像这样在外面呆了有十多年了，很难想象刚开始的那几年他是怎么熬过来的。不过此时此刻我也渐渐地习惯了如今一个人的生活，可能是邻居们都入住了吧哈哈，仔细想想，我在外面把自己照顾好，过得开开心心的，不也是家里人希望看到的吗？我能做的就是努力工作，经常给他们报报平安说说话。 关于工作尽管才入职两天，但是我已经感受到，这样的工作就是我想要的工作，不拘束的工作环境，平易近人的同事，热心指导新人的前辈们这些都让我感觉在这里工作挺亲切，虽然作为实习生，我还有相当多的东西需要学习。但是我相信在这几个月的实习中，我能够学到在学校里永远学习不到的东西，做技术，当然是技术上的提升才是最有成就感的。在这里给自己定一个小目标，在正式工作的时候，争取开发水平上升一个档次。当然最终要生活还是得谈到工资，那这里暂时把工资目标定位12k。加油！！！ 最后当然是要贴几张图啦，这是骑车图中拍的即将下雨之前的深圳天空：接下来是我即将实习几个月的地方——深圳市随手科技有限公司：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈Android中的Context]]></title>
      <url>%2F2017%2F06%2F24%2F%E6%B5%85%E8%B0%88Android%E4%B8%AD%E7%9A%84Context%2F</url>
      <content type="text"><![CDATA[官方对Context的解释这是Context类的声明和继承关系：可以看到Context是一个抽象类，在它的众多子类中，可以发现Activity、Service和Application的影子：谷歌api文档官方对Context类的解释如下： Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. 从上面的解释可以概括出，Context代表了应用的运行环境(上下文)，本身为抽象类，由安卓系统内部实现，通过Context对象我们可以访问某些资源和类，除此之外还可以用Context对象来启动一个activity，发送广播等。 更通俗的理解每个应用都运行在特定的上下文环境中，而Context类允许我们对应用的运行状态进行访问。正是因为有了Context，我们才可以在Activity中访问一些资源文件、图片、主题和样式以及系统的文件目录。除此之外，我们还可以通过Context来获取安卓系统内置的一些服务，比如访问网络状态等系统服务。由于Activity、Service和Application都继承自Context，所以一个应用中的context对象数量为三者的实例数量相加 Context的使用场景1.显式启动组件最常见的就是通过利用context来启动另一个Activity： Intent intent = new Intent(context, MyActivity.class); startActivity(intent); 这里显式启动一个活动需要两个信息： 应用的包名，它标识了该组件所在的应用 将要启动的目标组件的类权限定名其中，信息1在可以在传入的context上调用context.getPackageName()来获得；第二个信息通过传入的class对象的getClassName()来获得。 2.动态创建view在代码里创建一个view的时候也需要传入一个context对象，比如： ImageView imageView=new ImageView(context); 这里传入的context包含了如下的上下文环境： 用于将dp,sp单位转化为pixels的屏幕尺寸信息 组件对应的style样式 3.加载布局文件将xml布局文件加载到内存： LayoutInflater inflater = LayoutInflater.from(context); inflater.inflate(R.layout.my_layout, parent); 这里context主要用于加载xml文件的时候根据布局来创建view。 4.获取系统内置服务比如设备当前的网络服务，进而判断网络状态： ConnectivityManager connectivityManager= (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); 再如获取系统内置的Notification服务用于通知栏提示： // Context objects are able to fetch or start system services. NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); int notificationId = 1; // Context is required to construct RemoteViews Notification.Builder builder =new Notification.Builder(context).setContentTitle(&quot;custom title&quot;); notificationManager.notify(notificationId, builder.build()); 查看所有系统内置服务点我) Application Context和Activity Context因为activity、service和application都继承自context类，所以在大多数情况下，当我们的某些方法需要以context作为参数的时候，在activity中我们都可以简单地传入this就可以了，但是activity中还提供了getApplicationContext()方法来获得application对应的context，这两种context是有区别的，在有的情况下就只能使用activity对应的context，具体的使用情景如下表：与UI相关的context都最好使用activity对应的context，除此之外，application对应的context也可以用于启动一个activity，但是由于application与activity相比，没有所对应的任务栈(所有的activity都运行在对应的任务栈中)，所以用application context来启动activity的时候需要指定新的任务栈，这样就增加了任务栈的数量，不便管理，所以最好只用activity context来启动另一个活动 context引起的内存泄露由于context经常作为形参传入到其他方法中，如果对context使用不当导致在context本来应该被回收的时候（比如activity被销毁）仍然被持有，就会使得该context不能被回收，最终导致内存泄露。下面是两种比较明显的activity内存泄露情况： 1.静态成员持有context对象Public Class MyActivity extends AppCompactActivity{ static Textview mTextView; @override protect void onCreate(Bundle onSavedInstanceState){ mTextView = new TextView(this); } } 由于mTextView是一个静态成员变量(类变量)并且它持有当前activity的引用，所以一旦当该activity生命周期结束本该被回收的时候，由于静态变量的声明周期大于对象的声明周期，所以在该activity即将被回收的时候，mTextView不会被置为Null，而是会始终应用该activity，而activity将由于一直被引用而无法被GC回收，最终导致内存泄露。若声明为非静态变量，那么mTextView就会在activity被回收的时候被置为Null，而activity一旦不被任何引用持有，它就可以被标记为可回收对象，最终由GC回收。 2.单例模式导致的context内存泄露若某个单例对象包含context引用，而该context又不是application对应的context的话，就会导致contetx内存泄露，代码如下： Public Class Singleton{ Private Context mContext; Public Static Singleton getInstance(Context context){ //这里将引发内存泄露 this.mContext=context; return Holder.instance; } Static Class Holder{ Private Static Singleton instance = new Singleton(); } } 首先需要明白，在android中，单例对象的最大特点之一是其生命周期和application保持一致，为什么？我是这样理解的：试想一下，假如我GC现在想回收上面的单例对象，但是发现该对象被静态变量所引用，如果不是静态变量的话就可以在这时把这个引用置为Null，但是很明显，这里的Singleton是静态变量，始终不会被置为Null，而该单例对象又包含了context引用，那么当该context本该被回收的时候，会由于一直被单例对象持有而导致无法被回收，最终同样导致内存泄露。解决方法也很直观，那就是直接传入application context，因为application context的生命周期和应用一致，进而也就和单例对象一致，就不会面临本该被回收而不能被回收的局面将上面的注释下的代码修改如下： this.mContext=context.getApplicationContext(); 总结牢记一句话，UI相关用Activity context，单例模式用application context]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件服务基本知识]]></title>
      <url>%2F2017%2F06%2F17%2F%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[无意之间在廖雪峰的官网上看到了python的教程，简单浏览了一段，小有收获，对python有了浅显的认识，同时也收获到一些计算机的基础知识，简单做个记录，主要关于邮件服务的协议。 邮件收发的过程 首先涉及的几个名词： MUA:mail user agent,邮件用户代理，指我们平时使用的电子邮件软件，比如网易邮箱大师和foxmail等。 MTA:mail transfer agent,邮件传输代理，指的是email邮件服务提供商，如网易163、新浪和qq邮箱等等。 MDA:mail delivery agent,邮件投递代理。 这是廖雪峰官网中对邮件收发过程的描述：假如我现在用我的163邮箱coder_jason@163.com给我的qq邮箱1627642910@qq.com发一封邮件，我首先在网易邮箱大师（此时它就是MUA）里面编辑好了我的邮件，然后写上目标邮箱。点击发送之后的过程如下： 因为我的邮件发自网易邮箱，所以邮件首先会到达网易的MTA。 网易的MTA收到我的邮件之后会转发到qq邮箱的MTA qq邮箱的MTA再把邮件投放到MDA，邮件到达MDA之后，就会保存在qq邮箱的某个服务器上，当我们在未来的某时间登陆qq邮箱的时候，就可以收到新邮件提醒 最后再通过MUA将邮件从qq的MDA上取下来，邮件就保存到了本地 这个过程如下： 发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人 那么如果要自行编写一个客户端来收发邮件，实际上就包括了以下两个操作： 编写MUA，将邮件发送到MTA 编写MUA，从MDA上获取邮件 邮件服务相关协议 SMTP(发邮件时)：Simple Mail Transfer Protocol，将邮件从MUA发送到MTA时采用smtp协议，MTA到另一个MTA也是用SMTP协议。 POP(收邮件时)：Post Office Protocol，目前版本是3，俗称POP3，MUA从MDA上获取邮件时可采用pop协议 IMAP(收邮件时)：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。 邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。 类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。、 使用python来发送邮件这里使用python让我的网易邮箱给qq邮箱发一封邮件： from email import encoders from email.header import Header from email.mime.text import MIMEText from email.utils import parseaddr, formataddr //导入模块 import smtplib //header编码，防止中文乱码 def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr)) from_addr = input(&apos;From: &apos;) password = input(&apos;Password: &apos;) to_addr = input(&apos;To: &apos;) smtp_server = input(&apos;SMTP server: &apos;) msg = MIMEText(&apos;我是测试邮件&apos;, &apos;plain&apos;, &apos;utf-8&apos;) msg[&apos;From&apos;] = _format_addr(&apos;distancelin &lt;%s&gt;&apos; % from_addr) msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr) msg[&apos;Subject&apos;] = Header(&apos;来自SMTP的问候……&apos;, &apos;utf-8&apos;).encode() //smtp默认端口号为25 server = smtplib.SMTP(smtp_server, 25) //显示调试信息 server.set_debuglevel(1) server.login(from_addr, password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit() 登陆qq邮箱显示成功接收到邮件：这里能使用python来控制coder_jason@163.com发送邮件的前提是在网易邮箱里开启SMTP服务]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之适配器模式]]></title>
      <url>%2F2017%2F06%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[本篇博客最后修改于6/16/2017 4:14:04 PM最近学习《android源码设计模式》的同时，越来越感受到了设计模式在android源码中体现在相当多的地方，而且现今github上比较流行的开源库中也大都运用到了设计模式，这里先简单记录一下适配器模式的基本思想和例子，下一篇文章中会跟随android源码设计模式来梳理一下listview以及recyclerview中适配器模式的运用。 什么是适配器模式？ 适配器在生活中算是很常见了，就拿笔记本的电源适配器来说，它的作用是把220v的电压转化为5v的电压，因为笔记本的电源接口大多是5v的，这就出现了不兼容的情况，而适配器就起到了一个中间层的作用，将不兼容的220v电压转化为了笔记本兼容的5v电压。使得我们可以使用哪个220v电压来给笔记本充电，也就是220v电压和笔记本一起工作。简而言之，适配器模式，就是通过一个中间层(adapter)来将不兼容的接口转化为另一种接口，使得原本不兼容的两个类能够在一起协同工作。通过上述例子来对应，那就是，电源适配器(adapter)将220v的电压转化为5v电压，使得220v电压和笔记本协同工作。适配器模式的包括以下三个部分：adaptee： 需要被转化(适配)的类，如上面的220v电压adapter： 中间层适配器，起转化作用，如上面的电源适配器target： 转化之后的结果，如上面的5v电压adapter、adaptee应该声明为Class，而target通常对应了一个Interface。 适配器模式的分类适配器模式分为以下两类： 类适配器 对象适配器 其中类适配器通过继承的方式实现，而对象适配器通过组合的方式来实现。对象适配器比类适配器更加灵活，使用场景也更丰富。下面分别是采用类适配器和对象适配器来实现笔记本电源适配器的例子： 1.类适配器实现类适配器模式反映到java代码上最典型的特点就是继承，首先写出adaptee，也就是220v电压的充电， class V220 { public int get220() { return 220; } } 接下来是target对应的interface，5v： interface V5{ void get5(); } 最后是核心adapter，类适配器的核心是，adapter继承adaptee并实现target，按照这个规则，写出的adapter如下： class Adapter extends V220 implements V5{ @Override public int get5() { int temp=get220(); //将220v的电压转化为5v电压，这只是个模拟操作 return temp/44 } } 下面是测试用例： public class Computer { public static void main(String[] args) { Adapter adapter=new Adapter(); //充电5V adapter.get5(); } } 2.对象适配器实现对象适配器采用组合的方式来实现，核心是adapter包含了一个adaptee并实现了target，对应的代码如下： class Adapter1 implements V5{ V220 mV220; public Adapter1(V220 mV220) { this.mV220 = mV220; } @Override public void get5() { int temp=mV220.get220(); //将220v的电压转化为5v电压，这只是个模拟操作 return temp/44 } } 可以看到，和类适配器相比，不同之处在于，类适配器通过继承adaptee来获得get220v()方法，而对象适配器通过传入一个adaptee对象并通过组合的方式来获得get220v方法。java只支持单继承，所以这种方式比起类适配器来说更加灵活实用。总而言之，适配器模式当然是用来处理不适配，不兼容的情况，通过适配器来协调不兼容的两者，使得它们可以协同工作 其他另一种情况下的适配器：很多情况下，java中的一个interface里往往声明了许多抽象方法，而这个接口又很可能在许多地方都会用到，这时就可以创建一个新的Adapter类来实现该接口，并让所有的方法默认实现为空，在使用时就可以通过继承Adapter的方式来覆盖我们需要的那一部分方法而不用实现所有的抽象方法，在RxJava的观察者中就可以这样实现： public class ObserverAdapter&lt;T&gt; implements Observer&lt;T&gt; { @Override public void onSubscribe(@NonNull Disposable d) { } @Override public void onNext(@NonNull T o) { } @Override public void onError(@NonNull Throwable e) { } @Override public void onComplete() { } } 在RxJava的使用就可以这样写： call.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new ObserverAdapter&lt;NewsBean&gt;(){ @Override public void onNext(@NonNull NewsBean o) { callback.onBannerNewsFinish(o.getTop_stories()); callback.onLatestNewsFinish(o.getStories(),o.getDate()); } });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修改apk的debug签名]]></title>
      <url>%2F2017%2F05%2F26%2F%E4%BF%AE%E6%94%B9apk%E7%9A%84debug%E7%AD%BE%E5%90%8D%2F</url>
      <content type="text"><![CDATA[最近接手的爱课项目由于apk签名的问题导致微信分享和登陆出现错误，其实主要涉及apk的签名问题，查看了官方文档的解释，终于发现上学期学的信息安全知识派上了用场。这里作为一个简单的记录。官方文档之-签署你的应用 调试时使用的签名使用android studio进行调试的时候，如果没有特别指定应该使用哪一个签名文件的话，android studio将会使用默认的debug.keystore文件来签名apk，在windows系统里，这个文件位于C:\Users\username.android目录下，如下：在该目录下执行以下命令可以查看keystore中存放着的信息： keytool -list -v -keystore keystoreName 在进行调试的时候默认采用这些摘要进行apk签名，这里是微信所提供的apk签名获取软件，输入应用的包名就可以获取到apk的签名：微信apk签名工具 发布apk在生成apk的时候不应该还使用调试用的签名文件，这时需要先生成签名文件(.jks意味java keystore和.keystore无本质区别)，这样，在以后新版本apk发布的时候，必须使用相同的证书来对apk进行签名，只有这样才能保证apk的覆盖安装，否则必须卸载旧的版本才能安装新版本。 使用正式签名进行调试在调试的时候android studio默认使用debug.keystore来进行签名，而release版本需要我们自己新建的签名文件来签名，两种情况下得到的apk签名自然不同，而微信开放平台要求填写apk的签名，如下：因为填写的是apk的release版本签名，这就导致了在调试的时候因为apk签名不同而使得微信提供的功能不能正常使用，所以需要修改调试时的签名，使得和release版本签名一致：open module settings：这里设置为前面步骤新生成的.jks文件。接下来配置debug和release版本下的对应签名设置，这里都设置为了使用同一个签名文件进行apk签名。最后可以在module下的gradle文件中看到android studio为我们生成了如下的配置：这就完成了在debug版本和release版本的apk具有由相同的签名，调试的时候也不会出现微信签名不符的问题了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中几个常用文件目录]]></title>
      <url>%2F2017%2F05%2F21%2FAndroid%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%2F</url>
      <content type="text"><![CDATA[最近在进行图片下载的时候涉及到了文件的保存目录，安卓里提供了许多获取文件目录的方法，为了便于区别在这里作一个记录。安卓手机提供了内部存储(internal storage)和外部存储(external storage)来保存数据。 内部存储内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下，sharedPreference和sqlite数据库文件都存放在这个内部存储中，用activity的openFileOutput()方法创建的文件也存放在内部存储中。内部存储的目录一般是/data/data/packageName/,不同的手机有一定的差别，下面分别是我的真机和genymotion模拟器的内部存储目录： 这是ddms的fileExploer查看到的内部存储：可以看到内部存储按照应用的包名来管理文件，应用智能访问自己包名对应的文件。内部存储的所有数据在应用卸载之后会被删除 外部存储外部存储不只是指代sd卡，现在的很多手机不用插入sd卡，但是也存在外部存储，比如我的手机为64G，但是没有提供sd卡的扩展，但是这64G仍然指的是外部存储， 所有的安卓设备都有外部存储和内部存储，这两个名称来源于安卓的早期设备，那个时候的设备内部存储确实是固定的，而外部存储确实是可以像U盘一样移动的。但是在后来的设备中，很多中高端机器都将自己的机身存储扩展到了8G以上，他们将存储在概念上分成了”内部internal” 和”外部external” 两部分，但其实都在手机内部。所以不管安卓手机是否有可移动的sdcard，他们总是有外部存储和内部存储。最关键的是，我们都是通过相同的api来访问可移动的sdcard或者手机自带的存储（外部存储）。 外部存储可以存储应用私有的数据和公有的数据，区别在于在外部存储上的私有数据在应用卸载之后会被删除，而公有数据不会被删除，比如可以将用户下载的文件保存在外部公有文件中，这时在用户卸载应用的时候，文件下载的文件仍然可以保留。而如果缓存数据太多，保存在内部存储中可能会迅速占满内部存储，这时就需要把数据保存在外部存储的私有文件里。 外部存储的私有文件可以通过以下方式的到外部存储私有文件的目录：截图的后半部分是/com.distancelin.zhihudaily/file/pictures拿到这些目录之后就可以通过File类在外部存储创建私有文件了，如下： File file = new File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES), pictureName);} 以上代码在外部存储的picture目录下创建了名为pictureName的私有文件。 外部存储的公有文件在外存储上放公共文件可以使用getExternalStoragePublicDirectory() File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), pictureName); 在上面的代码中创建获得了存放picture的目录，并且新创建一个pictureName文件。api 版本低于8，那么不能使用getExternalStoragePublicDirectory()，而是使用Environment.getExternalStorageDirectory(),他不带参数，也就不能自己创建一个目录，只是返回外部存储的根路径,这时需要拿到路径之后自己通过File类的方法来建立文件夹，比如： //构建文件夹 String fileStoreDir = Environment.getExternalStorageDirect().getAbsolutePath()+File.separator+&quot;zhihudailyDownload&quot;; File dir = new File(fileStoreDir); File file = new File(dir+File.separator+mFilename); 以上的代码在外部存储中创建了/zhihudailyDownload/mfilename的文件。 总结将内部存储和外部存储的几个方法对应起来：可以看到对私有数据而言，内部存储保存在/data/，而外部存储保存在Android/data/，而外部公有文件需要我们自己去决定目录 顺便贴一下图片下载成功之后更新图库的方法，其实方法就是发送一个广播让图库应用去扫描添加图片： //参数分别为ContentResolver，需要扫描的图片绝对路径，图片的名称，描述符(为null即可) MediaStore.Images.Media.insertImage(getContentResolver(),file.getAbsolutePath(),mFilename,null); //发送广播，将文件解析为URI并设置给intent sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot;+file.getAbsolutePath())));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[官方文档学习之-高效加载大图]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BD%E5%A4%A7%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[本篇博客作为是图片加载的开端，为了更好地理解图片加载方面的知识，我参考官方文档进行一些练习，最后再比较综合地结合参考尝试构造一个基本的图片加载框架出来，尽管Glide已经独当一面了，但是图片加载的原理也定会让我收获不小。本文的google官网链接 不作优化的情况在安卓设备上显示图片最简单的方法就是将图片设置给imageview，这里的图片格式可以是png、jpg以及其他常见的格式。手机屏幕是有限的，许多情况下我们可能会在布局文件里设置imageview的宽高(比如100dp)，这时候将一张很大的图片设置给imageview，这种情况imageview加载图片的时候会把图片按照原来的大小整个加载进内存再设置给imageview，而imageview内部负责对图片进行缩放，虽然显示为小图，但是内存占用却是原来大图的大小。 这里用一张大图作为实验(934x623)：下面通过指定imageview宽高为100dp来进行显示，代码很简单： &lt;ImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:id=&quot;@+id/image&quot; android:layout_below=&quot;@+id/download&quot;/&gt; activity中的关键代码： imageView.setImageResource(R.drawable.jj); 内存占用如下（26.32MB）： 高效加载官方文档中提到，主要使用BitmapFactory.Options来缩放图片，主要使用到options的inSampleSize字段，它的意思是采样率，失踪应该取大于1的数值，比如inSampleSize=2时，采样后的图片宽高都为原来的1/2，那么图片的像素就变为了原来的1/4，官方推荐最好将inSampleSize总是设置为2的指数，如1、2、4、8…，假如设置为3的话系统可能会选择2来代替。通过采样率来加载图片的步骤： 将BitmapFactory.Options的inJustDecodeBounds设置为true并加载图片 从BitmapFactory.Options中取出原始图片宽高 根据采样率的规则以及view所需要的大小计算inSampleSize 将BitmapFactory.Options的inJustDecodeBounds设置为false,再次加载图片 inJustDecodeBounds设置为true的目的是在不把图片加载到内存的情况下获取图片的原始大小 根据以上四个步骤对应代码如下： public static Bitmap decodeSampleBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight){ final BitmapFactory.Options options=new BitmapFactory.Options(); // 1 第一次加载 options.inJustDecodeBounds=true; BitmapFactory.decodeResource(res,resId,options); //3 计算采样率 options.inSampleSize=caculateInSampleSize(options,reqWidth,reqHeight); //4.根据计算的采样率再次加载 options.inJustDecodeBounds=false; return BitmapFactory.decodeResource(res,resId,options); } private static int caculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { //获取图片的原始大小 int height=options.outHeight; int width=options.outWidth; //默认为1 int inSampleSize=1; //计算采样率 if(height&gt;reqHeight||width&gt;reqWidth){ int halfHeight=height/2; int halfWidth=width/2; while((halfHeight/inSampleSize)&gt;=reqHeight &amp;&amp; (halfWidth/inSampleSize)&gt;=reqWidth){ inSampleSize*=2; }} return inSampleSize; } 这样就得到了采样之后的图片，现在对应activity中的代码改为了如下： int width=imageView.getWidth(); int height=imageView.getHeight(); imageView.setImageBitmap(bitmapUtils.decodeSampleBitmapFromResource(getResources(),R.drawable.jj,width,height)); 内存占用如下(11.34MB)：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[volley学习之缓存篇]]></title>
      <url>%2F2017%2F05%2F09%2Fvolley%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[在前面简单地学习了volley的基本请求过程，那就是先访问缓存，缓存命中且没有过期就直接返回缓存的response，否则就进行网络请求，并对结果进行缓存，接下来再记录一下我对volley缓存部分的学习。 缓存目录的创建 缓存文件的创建是在第一次调用Volley.newRequestQueue()的时候,该方法中有如下代码： //DEFAULT_CACHE_DIR默认值为“volley” File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); .... //创建DiskBasedCache缓存 RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); 所以，volley是采用名为DiskBasedCache的类来实现缓存功能。跟踪来到DiskBasedCache的构造方法： public DiskBasedCache(File rootDirectory) { this(rootDirectory, DEFAULT_DISK_USAGE_BYTES); } DEFAULT_DISK_USAGE_BYTES的定义如下: //5MB private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024; 所以volley的默认缓存文件大小为5MB。这是DiskBasedCache中两个参数的构造方法，对缓存目录和缓存大小进行了赋值。 public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) { mRootDirectory = rootDirectory; mMaxCacheSizeInBytes = maxCacheSizeInBytes; } 而缓存文件的真正创建操作，是在Volley.newRequestQueue()中的queue.start()方法内部进行： public void start() { stop(); // Make sure any currently running dispatchers are stopped. // CacheDispatcher是继承自Thread的类，负责从缓存中读取数据 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); ... } CacheDispatcher是继承自Thread的类，负责从缓存中读取数据，它的run()方法如下： @Override public void run() { if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); mCache.initialize(); ... } mCache.initialize()进行缓存目录的创建： @Override public synchronized void initialize() { //这里新建名为volley的文件夹 if (!mRootDirectory.exists()) { if (!mRootDirectory.mkdirs()) { VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath()); } return; } ... } 以上进行了缓存目录的创建，在DDMS的file explore中对应了如下目录： 响应结果的cacheEntry创建缓存目录创建好了之后，在每次网络请求完成之后，就可以根据网络请求获得的response进行对应的缓存操作，由于具体的缓存文件创建和写入操作是在网络请求之后，所以缓存操作应该位于网络请求线程当中，来到mNetworkDispatcher中可以看到如下代码： NetworkResponse networkResponse = mNetwork.performRequest(request); // 解析，并创建response.cacheEntry Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); if (request.shouldCache() &amp;&amp; response.cacheEntry != null) { mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(&quot;network-cache-written&quot;); } 第一个条件可以通过request.shouldCache(boolean shouldCache)来设置，第二个条件不为空。mCache.put(request.getCacheKey(), response.cacheEntry)负责写入文件：参数1：request.getCacheKey()返回我们构建request时候传入的url(所以volley将request的url作为key来进行缓存)： public String getCacheKey() { return getUrl(); } 参数2：response.cacheEntry的创建过程如下： public static Cache.Entry parseCacheHeaders(NetworkResponse response) { long now = System.currentTimeMillis(); //map保存header Map&lt;String, String&gt; headers = response.headers; ... long softExpire = 0; long finalExpire = 0; long maxAge = 0; ... headerValue = headers.get(&quot;Date&quot;); if (headerValue != null) { serverDate = parseDateAsEpoch(headerValue); } //获得响应头中的Cache-Control字段，如Cache-Control:max-age=100,... headerValue = headers.get(&quot;Cache-Control&quot;); if (headerValue != null) { hasCacheControl = true; String[] tokens = headerValue.split(&quot;,&quot;); for (int i = 0; i &lt; tokens.length; i++) { String token = tokens[i].trim(); //不缓存 if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) { mustRevalidate = true; //取得服务器返回的Cache-Control的max-age值，单位为秒 } else if (token.startsWith(&quot;max-age=&quot;)) { try { maxAge = Long.parseLong(token.substring(8)); } catch (Exception e) { } } ... } } ... //根据max-age的值计算finalExpire if (hasCacheControl) { //毫秒，如当前时间为10，maxAge=40s,那么过期时间为10+40*1000 softExpire = now（毫秒） + maxAge * 1000; finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000; } ... //构建entry Cache.Entry entry = new Cache.Entry(); //响应体 entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; //该缓存的过期时间点 entry.ttl = finalExpire; entry.serverDate = serverDate; entry.lastModified = lastModified; //响应头 entry.responseHeaders = headers; return entry; } 上面有些代码的省略，这里的entry是根据response header来进行创建的，从最后entry的赋值可以知道，entry中主要保存了response的body、header、以及通过header计算而来的缓存过期时间，这样在再次访问该缓存的时候可以直接从entry中读取而不用每次从header中进行解析计算。 将缓存写入文件上一步根据返回的response计算出了缓存的过期时间和其他信息（保存在entry中），接下来就是以url为key,以entry为value将结果写入文件： mCache.put(request.getCacheKey(), response.cacheEntry) 实现如下： public synchronized void put(String key, Entry entry) { //写之前判断缓存大小是否超过最大值，超过则删除部分缓存 pruneIfNeeded(entry.data.length); //通过key找到对应的缓存文件，没有则创建 File file = getFileForKey(key); try { BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file)); //将entry构造成只包含header的对象，不包含body，但包含body的大小 CacheHeader e = new CacheHeader(key, entry); //将header写入文件 boolean success = e.writeHeader(fos); if (!success) { fos.close(); VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath()); throw new IOException(); } //将body写入文件 fos.write(entry.data); fos.close(); //将&lt;key,cacheHeader&gt;存入linkedHashMap中 putEntry(key, e); return; } catch (IOException e) { } boolean deleted = file.delete(); if (!deleted) { VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath()); } } 除了将header和body写入到文件之外，putEntry(key, e)方法会将存入名为mEntries的linkedHashMap中，这个linkedhashmap用来保存最近使用过的元素，当缓存超过最大容量的时候，就会通过e.key来获得对应的缓存文件，进而删除。实现了LRU算法的效果。这一过程如下： private void pruneIfNeeded(int neededSpace) { //没有超过最大容量就直接返回 if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) { return; } if (VolleyLog.DEBUG) { VolleyLog.v(&quot;Pruning old cache entries.&quot;); } long before = mTotalSize; int prunedFiles = 0; long startTime = SystemClock.elapsedRealtime(); //获取迭代器 Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next(); //获取之前putEntry(key,e)保存的e CacheHeader e = entry.getValue(); //根据e.key找到缓存文件并删除 boolean deleted = getFileForKey(e.key).delete(); if (deleted) { //删除成功则更新size mTotalSize -= e.size; } else { VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;, e.key, getFilenameForKey(e.key)); } //从linedhashmap中删除当前iterator所指的元素 iterator.remove(); prunedFiles++; //如果删除之后所剩占用的总空间&lt;最大容量*0.9(常量值为0.9f)则跳过该删除操作 if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) { break; } } if (VolleyLog.DEBUG) { VolleyLog.v(&quot;pruned %d files, %d bytes, %d ms&quot;, prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime); } 所以在缓存方面，volley使用了linkedHashMap来保存,通过遍历cacheHeader并统计所有cacheHeader.size的和便得到了当前所有缓存文件的总和，当缓存文件超过总容量的时候，再删除缓存文件直到文件总和等于0.9*maxSize。 通过linkedHashMap来保存的原因是因为linkedHashMap控制元素的遍历顺序： /** Map of the Key, CacheHeader pairs */ private final Map&lt;String, CacheHeader&gt; mEntries = //ture代表按照访问顺序排序 new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true); 第三个参数true的效果是：最近访问的元素会方法linkedHashMap的最后面，所以在删除文件的时候就可以直接删除第一个遍历到的元素对应的文件就行了，它就是最近最久未被访问的元素(LRU算法的思想)。 总结volley的请求遵循以下步骤： 将请求添加到缓存请求队列(由阻塞队列实现) 由cacheDispatcher根据请求的url作为key，在linkedHashmap中查找是否有值 值为空，则将请求添加到网络请求队列，值不为空但是过期也将添加到网络请求队列，值不为空且没有过期则直接返回缓存结果 网络请求执行，并缓存执行结果 DiskBasedCache中名为entries的linkedHashmap中，保存的元素和文件缓存一一对应，这样在判断缓存是否存在的时候，就可以在运行时直接读取linkedHashmap而不用每次去读取文件来判断(读取内存当然比读取磁盘更快) @Override public synchronized Entry get(String key) { CacheHeader entry = mEntries.get(key); // if the entry does not exist, return. if (entry == null) { return null; } ... }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安卓中的注解]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[注解的分类java中的注解按照处理方式可分为运行时注解和编译时注解。 运行时注解注解上的值需要在运行的时候通过反射机制来解析注解，以便根据注解的值来确定下一步的操作 编译时注解注解上的值在程序编译之后就已经完成了解析，在运行时可以直接根据解析的结果进行操作，编译时注解需要注解处理器(annotation processing tools,即apt)来完成，其中apt的作用是扫描.java文件中的注解信息并根据这些注解信息在特定的目录下自动生成.java文件，这些文件和普通的.java文件没有区别，我们可以直接调用这些.java文件中的方法。 自定义注解下面是一个典型的自定义注解的例子： @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface BindView { int value() default 0; } 1.注解中变量的声明需要加()2.当注解中只有一个变量时，最好声明为value(),这样就可以在使用注解时直接@DiView(1)而不用@DiView(value=1)了 元注解java提供了四种元注解，它们是：@Target@Retention@Documented@Inherited @Target@Target表示该注解作用的对象，可选值如下： @Target(ElementType.TYPE) //接口、类@Target(ElementType.FIELD) //成员变量@Target(ElementType.METHOD) //方法@Target(ElementType.PARAMETER) //形参@Target(ElementType.CONSTRUCTOR) //构造方法@Target(ElementType.LOCAL_VARIABLE)//局部变量@Target(ElementType.ANNOTATION_TYPE)//注解@Target(ElementType.PACKAGE) ///包 @Retention@Retention表示注解的生命期，它的可选项如下：@Retention(RetentionPolicy.SOURCE) // 注解只存在与源代码中@Retention(RetentionPolicy.CLASS) // 注解可存在与字节码文件中@Retention(RetentionPolicy.RUNTIME) // 注解可存活到运行时，在运行时仍然可以获取到该注解的值 除了以上两个元注解，java还提供了@Documented // 表示该注解会存在javadoc中@Inherited // 表示该注解可以被子类继承两个元注解。 @Inherited只有作用在类上能被子类继承，这里的继承指的是当父类上存在该注解时，其子类即使不声明该注解，但依然可以获取到该注解的值 注解本身不支持继承，即不能定义@interface child extends parent（其中parent为注解） 注解的解析为了对比两种解析方式，基于上面定义的注解BindView,来代替findViewById()这个方法。 通过反射public class ViewBinder { public static void bindwith(Activity activity) { Class class = activity.getClass(); //遍历成员变量 for (Field field : class.getDeclaredFields()) { //处理字段 if (field.isAnnotationPresent(BindView.class)) { IView anno = field.getAnnotation(IView.class); int value = anno.value(); try { //若变量为private则必须加上这一句 field.setAccessible(true); //意为将activity对象的field变量赋值为activity.findViewById(value) field.set(activity, activity.findViewById(value)); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } } 现在在Activity中就可以这样使用该注解来代替findViewById()了： public class ReflectActivity extends AppCompatActivity { @IView(R.id.button) Button mButton; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewBinder.bindwith(this); } } 这就是运行时通过反射来解析注解，但是反射可能对性能有部分影响。 通过自定义apt相比与反射，这种方式在编译时就完成了注解的解析，运行时直接调用就可以了，所以性能方面较好。在Android Studio中使用这种方式解析注解的步骤如下： 新建module、添加依赖 新建java library类型的module，并对该module添加依赖：auto-service依赖用于在项目中快速注册注解javapoet提供了一系列方法用于在注解解析阶段根据注解形成java类并生成.java文件，避免了我们自己通过字符串的方式构造类 在app module的gradle文件中添加依赖：lib是我新建的java librayr module名称 在project的gradle文件中添加依赖： 以上方法用到了android-apt插件，不过这个插件貌似第三方已经停止维护，取而代之的是Google官方的annotationProcessor如果使用annotationProcessor则不需要添加android-apt插件的依赖，只需要将apt project(‘:lib’)改为annotationProcessor(‘:lib’)即可 编写apt1.自定义注解bind，作用于类： @Target(ElementType.TYPE) @Retention(RetentionPolicy.CLASS) public @interface Bind { } 2.自定义注解bindView作用与成员变量： @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface bindView { int value() default 0; } 3.编写注解处理器 @AutoService(Processor.class) public class MyProcessor extends AbstractProcessor { private Elements elementUtils; //返回支持的注解类型 @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { return Collections.singleton(Bind.class.getCanonicalName()); } //扫描所有注解并生成.java文件 @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) { //扫描所有被@bind注解修饰的类 Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Bind.class); //遍历所有被@bind修饰的类 for (Element element : elements) { //TypeElement代表接口或者类 TypeElement typeElement = (TypeElement) element; //获得类的所有成员变量 List&lt;? extends Element&gt; members = elementUtils.getAllMembers(typeElement); //利用Javapoet生成方法 MethodSpec.Builder bindViewMethodSpecBuilder = MethodSpec.methodBuilder(&quot;bindView&quot;) .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(TypeName.VOID) .addParameter(ClassName.get(typeElement.asType()), &quot;activity&quot;); //扫描所有成员变量并取得其上@bindView注解的值 for (Element item : members) { bindView diView = item.getAnnotation(bindView.class); if (diView == null) { continue; } //为方法添加语句 bindViewMethodSpecBuilder.addStatement(String.format(&quot;activity.%s = (%s) activity.findViewById(%s)&quot;, item.getSimpleName(), ClassName.get(item.asType()).toString(), diView.value())); } //利用javapoet生成类 TypeSpec typeSpec = TypeSpec.classBuilder(&quot;DI&quot; + element.getSimpleName()) .superclass(TypeName.get(typeElement.asType())) .addModifiers(Modifier.PUBLIC, Modifier.FINAL) .addMethod(bindViewMethodSpecBuilder.build()) .build(); //将生成的写入.java文件 JavaFile javaFile = JavaFile.builder(getPackageName(typeElement), typeSpec).build(); try { javaFile.writeTo(processingEnv.getFiler()); } catch (IOException e) { e.printStackTrace(); } } return false; } //获取包名，用于指定生成的.java文件目录 private String getPackageName(TypeElement typeElement) { return elementUtils.getPackageOf(typeElement).getQualifiedName().toString(); } //解析之前最先调用 @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); elementUtils = processingEnv.getElementUtils(); } //jdk的版本 @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } } 最终我们在activity中就可以这样使用我们自己定义的注解了： @Bind() public class MainActivity extends AppCompatActivity { @bindView(R.id.button) Button mButton; @bindView(R.id.image) ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DIMainActivity.bindView(this); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[retrofit+okhttp网络请求本地缓存]]></title>
      <url>%2F2017%2F04%2F09%2Fretrofit-okhttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[本篇博客最后修改于 5/22/2017 7:07:53 PM移动端缓存的目的当然是希望用户在没有网络的情况下也能查看缓存过的内容对吧，以前学习Volley一次请求过程的时候其实已经接触到网络请求的缓存了 移动端缓存的典型作用 没有网络的时候，可以从缓存中获取到内容进而显示，虽然缓存中的内容不一定是最新的，但一定程度提高了用户体验。 节省流量，当用户频繁刷新获取数据时，由于来自服务器的数据很可能在短时间内没有变化，在数据无变化的情况下我们仍然使用自己缓存的数据，既节省流量又降低了服务端的压力。（该功能需要服务器端根据request header中的字段进行判断，进而决定返回304还是200，返回304的话，客户端就直接使用缓存就行了） 网络缓存的原理简析就拿经常使用的浏览器来说，发起请求的简单图解如下：图中涉及： 浏览器本地缓存 代理服务器缓存 其中代理服务器缓存是共享的，比如使用西南大学校园网的所有浏览器都可能使用的是同一台西南大学的代理服务器。 条件get方法条件get方法指的是在request header中添加了if-modified-since:sometime(某个时间)字段的get请求，这个sometime一般在上一次请求时由response header中的last-modified:sometime指定，当服务器接收到一个条件get请求的时候，会将request header中if-modified-since指定的时间与最后修改时间进行比较，若相同则返回304，代表未修改，那么浏览器就可以继续使用缓存的数据，否则会返回200和新的数据，浏览器再进行缓存的更新。 现如今，条件get方法也可以通过response header的Etag返回一个标识（字母+数字），而request header则添加的是if-none-match字段，原理类似if-modified-since。 与缓存相关的头字段不同版本的http协议中缓存相关头字段有区别，在okHttp中控制缓存主要通过拦截器来重写request header的Cache-Control字段来实现，关于Cache-Control字段以及更多缓存相关字段在一下链接中给出了详细的解释：http缓存头字段详解 retrofit+okHttp实现本地缓存okHttp不需要和retrofit搭配也可以实现缓存，只是retrofit以接口和注解的方式来进行get和post方法的定义更加简洁。该缓存功能主要是通过在拦截器里修改response header，实现缓存的具体代码： //getInstance方法用于获取一个retrofit 请求对象 public static &lt;T&gt; T getInstance(Class&lt;T&gt; classType) { //设置cache文件的大小 int cacheSize = 20 * 1024 * 1024; //在指定目录下创建缓存文件 Cache cache = new Cache(new File(APP.getApplication().getCacheDir(), &quot;okhttpCache&quot;), cacheSize); //创建okhttpClient对象并添加拦截器(用于rewrite请求头和响应头) OkHttpClient okHttpClient = new OkHttpClient.Builder() .cache(cache) .addInterceptor(mNETWORK_INTERCEPTOR) .addNetworkInterceptor(mNETWORK_INTERCEPTOR) .addInterceptor(mHttpLoggingInterceptor) .build(); //retrofit配合rxjava发送请求 Retrofit retrofit = new Retrofit.Builder() .baseUrl(NewsApi.NEWS_API_URL) .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create()) //adapter用于在retrofit接口中返回rxjava的observable对象 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); T t = retrofit.create(classType); return t; } 接下来是拦截器的具体代码(okhttp在发送request之前和获得response之后都会调用到拦截器的方法)： private static final Interceptor mNETWORK_INTERCEPTOR = new Interceptor() { @Override public okhttp3.Response intercept(Chain chain) throws IOException { okhttp3.Request request = chain.request(); okhttp3.Response originalResponse = chain.proceed(request); //读取retrofit接口上的@Headers里的配置，并设置到response header里 String cacheControl = request.cacheControl().toString(); return originalResponse.newBuilder() .header(&quot;Cache-Control&quot;, cacheControl) .removeHeader(&quot;Pragma&quot;) .build(); } }; 下面是retrofit接口的代码： public interface NewsTypeApi { //设置cache新鲜时间600s0，即获得第一次获得response并cache之后，该cache在600s之后失效 @Headers(&quot;Cache-Control: max-age=600&quot;) @GET(&quot;index&quot;) Observable&lt;NewsBean&gt; call(@Query(&quot;type&quot;) String type, @Query(&quot;key&quot;) String key); } 工作机理上述代码简单的工作流程可概括为下图（自己画的，有点丑） 因为在retrofit的get方法中设置了max-age=600，就意味着cache在600s后过期，而okhttp会把过期时间记录到缓存文件里，在下次访问命中该缓存时就首先会判断缓存是否过期，过期又没网的话是自然是读取不到任何数据的，此时就应该提醒用户联网重新获取数据了。 max-age和max-stale这两者都和缓存有效期相关，举个例子来帮助理解。 Cache-Control: max-age=60,max-stale=60意味着我获得的response缓存将在60秒之后过期，但是过期之后并不意味着不可用了，因为max-stale=60，所以我仍然可以在过期之后的60秒内使用该缓存。那么该缓存存在的总时间=60+60=120秒，超过120秒之后，该缓存将被从文件系统上删除(我们知道okhttp缓存是保存在文件上的)max-stale只在请求头有效，max-age请求头和响应头均有效 总结不知道你发现没有，我们到这里只是实现了缓存中的第一个功能：——在没网的时候访问缓存数据，这样在拦截器里强行修改响应头虽然不好，但在服务器没有给我们返回缓存相关的header时，这倒是一种可行的办法，假如response header里本来就包含cache control字段了，也就完全不需要我们来手动配置拦截器了。如果要实现第二个功能——有网的时候，用户刷新数据从服务器得到的数据可能和此刻本地缓存的数据一样(比如新闻客户端中，刷新之后可能新闻内容并没有增加)，那么此刻服务器就应该返回304代码，告诉客户端没有数据改变，你可以继续使用你的缓存，这样就节省了流量。 客户可以通过条件get方法来查询服务器资源是否修改，但是这需要服务端的支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android判断网络是否连接]]></title>
      <url>%2F2017%2F04%2F05%2FAndroid%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E8%BF%9E%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[今天使用retrofit+okhttp实现网络请求本地缓存的时候(在服务端不支持的情况下)，遇到本地缓存始终不能读取到的问题，一开始还以为Cache-Control设置错了，结果最终发现是判断网络状态出了问题，在这里记录一下。最终需要实现的效果是，有网就访问服务器，没网就访问缓存(对网络请求的缓存由okHttp自带，Volley也具有该功能)，关于缓存部分在下一篇博客记录，这里简单记录一下判断网络状态的方法： 判断网络是否连接public class NetUtil { public static boolean isNetworkAvaliable(){ ConnectivityManager connectivityManager= (ConnectivityManager) APP.getApplication().getSystemService(Context.CONNECTIVITY_SERVICE); //没网时info返回为null NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isConnected()) { //这层if可要可不要 if (info.getState() == NetworkInfo.State.CONNECTED) { return true; } } return false; } } 我的代码如下： public class NetUtil { public static boolean isNetworkAvaliable(){ ConnectivityManager connectivityManager= (ConnectivityManager) APP.getApplication().getSystemService(Context.CONNECTIVITY_SERVICE); //若网络没有开启，info的返回值为null NetworkInfo info = connectivityManager.getActiveNetworkInfo(); return info.isConnect(); } } 有网的时候能够正常执行返回true，没网的时候由于返回的info=null,进而影响到网络的判断。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法复习之——堆排序]]></title>
      <url>%2F2017%2F03%2F27%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[前言堆排序利用完全二叉树的思维来进行堆排序的实现，但是并不需要我们在排序的时候建立一棵完全二叉树。这一切都是基于数组之间元素的交换来进行的。 基础知识完全二叉树：在完全二叉树中，假如结点从1开始编号，父结点和子结点之间的序号存在如下关系：若父结点序号为i，则孩子结点序号：左孩子——2 i右孩子——2 i+1最后一个非叶子结点的编号——n/2（n为结点总个数）因为数组的下标从0开始，所以在对数组进行堆排序的时候，上述关系变为如下所示：左孩子——2 * i+1右孩子——2 * i+2最后一个非叶子结点的编号——n/2-1 大顶堆和小顶堆大顶堆——每个父结点的值大于子结点的值小顶堆——每个父结点的值小于子结点的值 堆排序介绍基本思想 将数组与二叉树等价看待——堆排序是将待排序的数组看作一颗完全二叉树,该二叉树的结点从上到下、从左到右对应数组中的每一个元素，二叉树的下标编号即为数组的索引编号。 构建堆(大顶堆或小顶堆)——从最后一个非叶子结点开始，将该结点和其孩子结点进行比较，并把三者的最小值或者最大值与该结点进行交换。使得这三者在局部上成为大顶堆或小顶堆。如此进行直到到达根结点 构建堆完成之后，将堆顶元素与堆的最后一个元素交换，并剔除最后一个元素，继续执行第二步，将剩下的元素调整为大顶堆或者小顶堆，直到所有元素被剔除。 例子现在的待排序数组为：4 1 3 2 16 9 10 14 8 7 一.建立大顶堆 首先将该数组视为一棵完全二叉树： 找到最后一个非叶子结点值为16（编号5），将其与左孩子比较，因为16&gt;7，不交换，则对16的前一个结点2(编号4)，进行同样操作，比较2和其孩子结点，因为14在三者中最大，所以将2和14交换得到如下： 继续对14(编号为4)的前一个结点3(编号为3)进行上述操作得到下图： 对1(编号为2)的结点进行调整之后，发现值为1和7的结点之间不满足大顶堆性质，将1视为当前结点，进行上述2的调整（此时应该交换1和7）： 类似步骤省略，最终由该数组形成的大顶堆如下:二.排序 将堆顶元素和最后一个元素交换，那么最大的元素就到了数组的最后一位： 将剩下的元素调整为堆： 重复1和2，最终整个数组有序。 show me the codepublic class Test { public static void main(String[] args) { int[] a = { 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 }; buildHeap(a); heapSort(a); System.out.println(Arrays.toString(a)); } private static void heapSort(int[] a) { for (int i = a.length - 1; i &gt;= 1; i--) { //交换第i个元素和堆顶元素 swap(a, 0, i); //调整剩下的元素调整为堆 adjustHeap(a, i, 0); } } private static void buildHeap(int[] a) { // 数组中最后一个非叶子节点的下标 int startIndex = a.length / 2 - 1; //从该结点向前直到根结点，调整为堆 for (int i = startIndex; i &gt;= 0; i--) { adjustHeap(a, a.length, i); } } private static void adjustHeap(int[] a, int length, int index) { //若当前结点存在左孩子 while ((2 * index + 1) &lt; length) { int leftChild = 2 * index + 1; int rightChild = leftChild + 1; int max = leftChild; //若当前结点存在右孩子 if (rightChild &lt; length) { // 将较大的一个孩子下标赋值给max max = a[leftChild] &gt; a[rightChild] ? leftChild : rightChild; } // 建立局部大顶堆，保证三者中最大的元素成为父结点 if (a[index] &lt; a[max]) swap(a, max, index); //因为交换之后可能导致子结点之间不满足堆的性质，还需要对子结点进行相同操作 index = max; } } // 交换数组中下标为max和index对应的元素，因为直接操作数组，所以可以完成交换 private static void swap(int[] a, int max, int index) { int temp = a[max]; a[max] = a[index]; a[index] = temp; } } 执行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法复习之——直接插入排序]]></title>
      <url>%2F2017%2F03%2F22%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[直奔主题直接插入排序的基本思想：首先将数组的第一个元素看成有序的、长度为1的数组，从第二个元素开始将第二个元素插入到前面的有序数组中合适的位置，使得有序数组变为长度为2的有序数组，以此循环进行，直到遍历完原来数组的所有元素。最终使得整个数组有序。 怎么找到插入的合适位置？要找到插入的合适位置，可以在前部分有序数组中从后往前搜索，直到找到第一个小于待排元素的元素，合适的位置即为该元素的下一个位置，寻找位置的同时将有序数组中大于待排元素的所有元素后移一位。即a[j+1]=a[j]。 举个栗子现在有如下数组：(5) 2 7 6 9将5看做长度为1的有序数组，从2开始，首先将2保存下来(int temp=a[i])，在有序数组中从后往前搜索，5&gt;2，所以用5将2覆盖，此时数组为：5 5 7 6 9，继续向前搜索发现刚才搜索的5已经是有序数组的第一个元素，代表有序数组中没有比2小的数，所以将2放在第一位得到以下数组：(2 5) 7 6 9对下一个数7继续上述操作，得到:(2 5 7) 6 9对6继续上述操作，得到：(2 5 6 7) 9最终得到：2 5 6 7 9 show me the codepublic class InsertSort { public static void main(String[] args) { int[] a = { 23, 100, 55, 2, 56, 2, 99, 0, 23, 44, 103, 1, 2000 }; insertSort(a); System.out.println(Arrays.toString(a)); } private static void insertSort(int[] a) { // 从第二个元素开始进行插入排序 for (int i = 1; i &lt; a.length; i++) { // j是i的前一个元素 int j = i - 1; // 因为可能进行有序数组原色后移，先保存先来当前待排序的元素 int temp = a[i]; // 在有序数组中找到第一个小于待排元素的位置，同时把大于待排元素的数往后移动一个位置 while (j &gt;= 0 &amp;&amp; a[j] &gt;= temp) { a[j + 1] = a[j]; j--; } // j是有序数组中第一个小于待排元素的元素，待排元素应该放在它的下一位 a[j + 1] = temp; } } } 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法复习之——快速排序]]></title>
      <url>%2F2017%2F03%2F22%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[闲扯自从上一篇关于Volley的文章之后，被实习折磨的我就基本停止了更博，一方面想急着找实习，另一方面却又一直感觉自己学的知识不是特别扎实，复习了几天也不知道复习的效果到底怎样，加上昨天收到阿里的一面，问得比较基础（全是项目相关）感觉也还算顺利，不过我有种预感，可能挂了，还是一步一步慢慢来吧。 言归正传先来解释一下快排的基本步骤： 选择基准元素（一般为数组的第一个元素） 通过第一次划分将大于基准的元素放置到基准元素的后面，将小于基准的元素放置到基准的前面，这样整体看来，基准之前的元素、基准元素、基准之后的元素三者之间变成了有序的。 分别对位于基准元素之前和之后的部分进行相同的操作，最终整个数组有序。 每次划分的基本操作划分的基本思想是首先保存基准的值，再设置两个游标，low和high，分别指向当前数组的第一个和最后一个元素，首先从high开始，向前搜索到第一个小于基准的元素，并用该元素覆盖基准（此时相当于此处形成了一个重复的元素）；再从low开始，向后搜索到第一个大于基准的元素，用此元素覆盖前一步所形成的重复元素，重复这两个步骤知道low==high。 举个栗子一个简单数组如下（基准为5）：首先把基准5保存下来，int povit=a[low]，此时可以认为5的位置形成了一个坑。5(坑) 7 3 4 9 （low=1，high=3）第一步：从9开始向前搜索到第一个小于基准的元素为4，用4覆盖5（因为4去覆盖了5位置上的坑，所以原来4的位置上形成了坑），得到数组如下：4 7 3 4(坑) 9 （low=1，high=3）第二步：从7开始向后搜索到第一个大于基准的元素为7，用7覆盖4位置上形成的坑，结果如下：4 7(坑) 3 7 9 （low=1，high=3）第三步：重复第一步，从后向前搜索下一个小于基准的元素为3，同理进行填坑，结果如下：4 3 3(坑) 7 9 （low=1，high=2）第四步：重复第二步，从前向后搜索下一个大于基准的元素（执行low++），此时low==high==2，结束搜索，用保存的基准值 povit=5 填坑，得到以下数组： 4 3 5 7 9 经过一次划分，大于5的元素排列到了5的后面，小于5的排列到了5的前面，接下来就递归对5的前半部分和后半部分进行划分操作。最终使得整个数组有序。 show me the code以上的方法叫做填坑法，还有基于交换的快排，不过我更喜欢填坑的方式，下面是填坑法的快排代码： public class QuickSort { public static void main(String[] args) { int[] a = { 23, 100, 55, 2, 56, 2, 99 }; quickSort(a, 0, a.length - 1); System.out.println(Arrays.toString(a)); } private static void quickSort(int[] a, int low, int high) { if (low &lt; high) { // 获得每次划分之后的基准元素位置 int q = partition(a, low, high); // 前半部分进行快排 quickSort(a, low, q - 1); // 后半部分进行快排 quickSort(a, q + 1, high); } } private static int partition(int[] a, int low, int high) { // 保存每次划分的基准元素 int pvoit = a[low]; while (low &lt; high) { // 从后向前搜索第一个小于基准的元素位置 while (low &lt; high &amp;&amp; a[high] &gt;= pvoit) high--; // 填坑，但high的位置上形成了新的坑 a[low] = a[high]; // 从前向后搜索第一个大于基准的元素位置 while (low &lt; high &amp;&amp; a[low] &lt;= pvoit) low++; // 填坑，low的位置形成了新的坑 a[high] = a[low]; } // 当循环结束时，low==high // 用最开始保存的pvoit填最后一个形成的坑 a[high] = pvoit; return high; } } 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[volley的简单分析]]></title>
      <url>%2F2017%2F02%2F28%2Fvolley%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Volley简介众所周知，Volley是google在2013年开源的一款异步异步异步http网络请求库，采用Volley进行网络请求非常简单。那么怎样个异步法？最简单的解释就是：使用Volley你不用再像原生的HttpUrlConnection一样new Thread(new runable());新开工作线程这些事Volley都帮你做了。Volley为http请求提供了如下的保障： response缓存。Volley内部维护了一个cache，用来对网络请求的结果进行缓存，再次发起该请求时会首先访问cache，当请求内容和上次相同时会直接从cache返回数据，避免重复的网络请求。 request请求队列，Volley会将通过request.add()方法添加的request放置在请求队列，并从该队列中逐一取出请求进行请求。并支持请求优先级的设置。 response分发。Volley采用异步的请求方式，请求成功并获得返回值时会在工作线程中对结果进行解析，并将response分发到主线程，意味着在Volley的回调方法中，代码直接运行在主线程，方便了UI更新等操作。这一点和okHttp有很大区别，okHttp异步方式的回调仍然运行在工作线程。这样不同的实现也各有各的好处。 支持request的自定义，Volley原生request包括了JsonRequest、JsonArrayReuqest、ImageRequest和StringResquest四种，分别用于json对象、json数组以及字符串类型的返回值请求，除此以外，Volley允许继承Request类实现自己的请求，比如你可以实现返回一个JavaBean的请求。 Volley适合频繁但数据量不大的网络请求，例如常见API调用，并不适合大文件的下载。Volley将整个response加载到内存并进行操作（可以是解析等操作）大文件可能会引起OOM官网对Volley的介绍 Volley简单使用最简单Volley的使用包括三个步骤： 创建RequestQueue 创建Request 将Request添加到RequestQueue RequestQueue requestQueue = Volley.newRequestQueue(context); StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() { @Override public void onResponse(String response) { //这里可以更新UI } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { } }); requestQueue.add(stringRequest); 本文的重点是分析Volley的工作流程，各种请求的具体使用可以参考以下链接：郭霖教你学Volley Volley原理解析先来一张Volley工作流程图镇楼：Volley中包括以下几种线程： 缓冲读取线程(cacheDispatcher)——用于从缓冲中获取数据(继承自Thread) 网络请求线程(networkDispatcher)——用于发送网络请求来获取数据(继承自Thread) response分发线程(mResponsePoster)——用于将请求结果(可能来自cache和网络)分发到主线程(Executor对象) 1.RequestQueue的创建既然使用Volley首先创建的是RequestQueue对象，那我们就从Volley.newRequestQueue(context)方法开始。该静态方法通过调用重载的静态方法，内部调用构造方法创建一个requestQueue对象： public static RequestQueue newRequestQueue(Context context, HttpStack stack) { //创建缓存 File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = &quot;volley/0&quot;; try { String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + &quot;/&quot; + info.versionCode; } catch (NameNotFoundException e) { } if (stack == null) { //API9及以上则使用HttpUrlConnection if (Build.VERSION.SDK_INT &gt;= 9) { stack = new HurlStack(); } else { //小于9则使用HttpClient // Prior to Gingerbread, HttpUrlConnection was unreliable. stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } //用于后面的网络请求 Network network = new BasicNetwork(stack); //根据设置的缓存目录创建请求队列 RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); //启动请求队列 queue.start(); return queue; } 从上面的代码可以发现，Volley内部是采用HttpUrlConnection或者HttpClient进行网络请求的(HttpClient已经废弃不再维护)。 我们重点关注一下这一行代码： RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); 以上代码创建了一个新的请求队列。并传入DiskBasedCache(cacheDir)来根据相应目录初始化缓存。跟踪上述构造方法，发现调用了另一个三个参数的构造方法： public RequestQueue(Cache cache, Network network) { //调用三个参数的构造方法 this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE); } DEFAULT_NETWORK_THREAD_POOL_SIZE是声明的常量=4，所以我们知道Volley的网络请求线程数量默认为4个。上述构造方法调用了四个参数的构造方法： public RequestQueue(Cache cache, Network network, int threadPoolSize) { //调用四个参数对的构造方法 this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper()))); } 注意以上方法的最后一个参数，这是一个绑定了主线程handler的ExecutorDelivery对象，用处在后文进行说明四个参数的构造方法的实现： public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) { mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery; } 这样requestqueue就创建完成， 2.网络请求的执行创建的requestqueue.queue.start()方法在创建的最后一行得到了调用。queue.start()的具体实现： public void start() { stop(); // 确保现有的dispatcher停止工作 // 创建cacheDispatcher并启动 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); //根据线程池(mDispatchers)的大小创建网络请求线程。 for (int i = 0; i &lt; mDispatchers.length; i++) { NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,mCache, mDelivery); mDispatchers[i] = networkDispatcher; //按创建顺序启动对应的线程 networkDispatcher.start(); } } 正如代码的注释一样，先创建并启动缓存线程用来读取缓存内容，再创建网络请求线程用于网络请求。mDispatchers为线程数组，默认大小为4，networkDispatcher网络请求执行线程。我们重点分析一下网络请求线程的创建： NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,mCache, mDelivery); 我们着重关注一下mDelivery对象，它是一个绑定了主线程handler的ExecutorDelivery对象 由于NetworkDispatcher本身是一个线程，调用start()方式实际会执行它的run()方法，我们来到run()方法内部： @Override public void run() { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) { long startTimeMs = SystemClock.elapsedRealtime(); Request&lt;?&gt; request; try { //从请求队列中取出网络请求 request = mQueue.take(); } catch (InterruptedException e) { // We may have been interrupted because it was time to quit. if (mQuit) { return; } continue; } try { request.addMarker(&quot;network-queue-take&quot;); //判断请求是否取消，取消则不执行该请求 if (request.isCanceled()) { request.finish(&quot;network-discard-cancelled&quot;); continue; } addTrafficStatsTag(request); // 发送网络请求 NetworkResponse networkResponse = mNetwork.performRequest(request); ... // 在子线程解析返回结果 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); ... 省略的代码用于请求成功的结果进行缓存 ... //将请求的结果发送出去 mDelivery.postResponse(request, response); } catch (VolleyError volleyError) { volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); } catch (Exception e) { VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); } } } 代码比较多，由于主要研究网络请求部分，上述代码的请求结果缓存部分我进行了省略，你可以自行查看源码。上述代码的核心在于以下三个方法： mNetwork.performRequest() Response&lt;?&gt; response = request.parseNetworkResponse() mDelivery.postResponse(request, response); 避免代码过多我就不贴源代码了，作用： mNetwork.performRequest()——最终调用HurlStack().performRequest()方法采用httpUrlConnection的方式进行网络请求。 request.parseNetworkResponse()——根据parseNetworkResponse()的具体逻辑实现在子线程对结果进行解析(这也是自定义Request需要实现的方法之一，比如需要返回javaBean就需要该方法中进行解析) mDelivery.postResponse(request, response)——将解析结果分发到主线程 3.Response的分发最后我们来看看Response的分发。mDelivery是一个ExecutorDelivery对象，内部存在一个成员对象叫做mResponsePoster(为Executor类型)，最终调用这个mResponsePoster.execute()方法对response进行分发。具体过程如下：mDelivery.postResponse(request, response)方法怎么把结果分发到主线程：该方法实现如下，调用了重载的postResponse(request, response, null)方法： public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) { postResponse(request, response, null); } 源码如下： public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) { request.markDelivered(); request.addMarker(&quot;post-response&quot;); //执行分发 mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); } mResponsePoster也是一个Executor对象，通过execute()方法来执行Runnable对象的run()方法：它的execute()方法实现如下： public ExecutorDelivery(final Handler handler) { // 采用handler.post()方法将runnable对象运行在主线程 mResponsePoster = new Executor() { @Override public void execute(Runnable command) { handler.post(command); } }; } 可以看到这里使用了handler.post()来使得runnable对象运行在与该handler所绑定的线程中那么这个handler是在哪里赋值的呢？往上翻，那就是在前文中两次注明的mDelivery对象，它是一个绑定了主线程handler的ExecutorDelivery对象，所以这里的handler是和主线程绑定的，在分发response的时候，我们的回调方法最终会运行在主线程。ResponseDeliveryRunnable类的run()方法部分代码实现如下： // 分发请求结果或者错误消息 if (mResponse.isSuccess()) { mRequest.deliverResponse(mResponse.result); } else { mRequest.deliverError(mResponse.error); } deliverResponse(mResponse.result)也是在自定义Request的时候可以覆盖的方法。在Volley自带的StringRequest类中，该方法实现如下： @Override protected void deliverResponse(String response) { mListener.onResponse(response); } 这里就调用了我们在使用Volley创建StringRequest对象时设置的监听器的onResponse(reponse)方法。然后就可以在改方法中更新UI了。 Volley用到线程池了吗？直观地看来，Volley是没有用到线程池的，它采用的是一个默认长度为4的线程数组(名为mDispatcher)，在具体的网络请求线程(networkDispatcher)的run()方法中，Volley采用了如下的结构： public void run(){ while(true){ //从请求队列中取出请求 requestQueue.take(); ... } } 这个死循环使得run()方法永远不会结束，对应的线程也就不会被销毁，而当requestQueue.take()没有获取到请求的时候(即请求队列已空)，该线程就会被阻塞而暂时停止运行。有新的请求的时候又得到运行进而发送新的网络请求。可以发现，Volley没有使用线程池来管理网络请求线程，而是采用死循环的方式来避免了不断地创建、销毁线程带来的开销，达到了和线程池同样的效果。 最后这里只是简单梳理了一遍Volley的网络请求流程，对缓存部分没有作讲解，若想了解更多，还请读者自行查看源码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义view和viewgroup]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%92%8Cviewgroup%2F</url>
      <content type="text"><![CDATA[前言我的上一篇博客对view的绘制过程作了介绍，那么接下来当然是创造自己的view，为了方便描述，下文依然将使用view代表不能包含子内容的控件，用viewgroup代表容器，但是实际上viewgroup也是view（ViewGroup类继承自View类）。由于最近才开始正式探索view方面的知识，所以这几篇文章也是对我学习view的一个记录吧，知识参考自View和ViewGroup源码以及《Android群英传》 View类的重要方法 这里介绍的是继承View类或者ViewGroup类进行自定义，组合控件以及继承现有控件不涉及。首先明确：在前一篇文章view的绘制中提到的measure()、onMeasure()layout()、onLayout()draw()、dispatchDraw()、onDraw() 这些方法全都是View类中声明的方法，其中measure()方法为final类型不可覆盖。 1.自定义view简介自定义view需要继承View类，并且覆盖onMeasure()（以便支持wrap_content属性）、onDraw()，因为view的位置实际是在layout()方法中通过setframe()方法进行设置的，而layout()在View类声明的时候已经实现这一操作，所以自定义view不必修改layout(),也一般不必覆盖onLayout()方法。 2.自定义viewgroup简介ViewGroup类继承自View类并且将onLayout()方法覆盖声明为abstract，所以自定义viewgroup必须实现该方法，由于viewgroup的位置也已经在layout()中设置完毕，所以onLayout()方法的唯一作用就是遍历子view并调用子view的layout()方法来布局子view。同自定义view一样，要想支持wrap_content属性，就必须覆盖onMeasure()方法,而ViewGroup类的onMeasure()只负责测量自身（仅仅使自己充满父布局），所以必须重写来重新测量自身和包含的子view。 谁来决定view的大小？view的大小最终是由自身决定的，而外层的viewgroup只是获取该view的xml属性，并且根据该属性进行大小的具体赋值，比如： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.distancelin.demo.MainActivity&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; 在LinearLayout的onMeasure()方法中，会获取到Button中所定义的两个wrap_content属性，对应了MeasureSpec.AT_MOST情况，但是LinearLayout只知道这个Button的mode是MeasureSpec.AT_MOST，并不知道具体的数值应该是多大，所以LinearLayout就会通过具体的逻辑对具体大小赋值：并且将赋值之后的数值连同Button的mode一起封装在MeasureSpec对象中传递给Button的measure()方法。这就是measure()方法中两个参数的来源。ViewGroup类中的measureChild()方法就是这一过程的最简单实现： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { //获取子view布局参数 final LayoutParams lp = child.getLayoutParams(); //对子view的具体大小赋值 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); //通过measure()将大小传递给子view child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 而measure()方法最终又将这两个参数传递给了自己的onMeasure()方法，在这里就可以根据自己的逻辑重新设置需要的大小。其中getChildMeasureSpec()就是根据自己的大小，分情况对子view的大小进行赋值： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 可以看到，不管是view还是viewgroup的大小，最终都是在自己的onMeasure()方法中决定的，他们的父视图只负责获取view或者viewgroup的xml属性并根据属性对大小进行赋值，最终传递给子view的onMeasure()方法。所以我是这样理解的，一个view的大小是在父viewgroup的控制之下，由自己在onMeasure()中调用setMeasuredDimension()最终确定的。 谁决定了view的位置？和大小同理view的位置同样是是在父viewgroup的控制之下，由自己在layout(int left,int top,int right,int bottom)中调用setFrame()最终确定的。ViewGroup.onLayout()用来布局子view，View.onLayout()方法实现为空。 实践——自定义viewgroup根据书中描述的过程 实现类似照片浏览的功能，滑动显示每个视图，并根据滑动的距离来决定是否进入下一个视图 public class ScreenScrollView extends ViewGroup { private int mScreenHeight; private int mScreenWidth; private int mLastY; private Scroller mScroller; private int mStart; public ScreenScrollView(Context context) { this(context, null); } public ScreenScrollView(Context context, AttributeSet attrs) { super(context, attrs); mScroller = new Scroller(context); WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); mScreenHeight = wm.getDefaultDisplay().getHeight(); mScreenWidth = wm.getDefaultDisplay().getWidth(); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) { View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) { childView.layout(1, i * mScreenHeight, mScreenWidth-1, (i + 1) * mScreenHeight); } } } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //super.onMeasure()使得该viewGroup充满父布局 super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); LayoutParams mlp = getLayoutParams(); mlp.height = mScreenHeight * childCount; setLayoutParams(mlp); for (int i = 0; i &lt; childCount; i++) { View childView = getChildAt(i); measureChild(childView, widthMeasureSpec, heightMeasureSpec); } } @Override public boolean onTouchEvent(MotionEvent event) { int y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: mLastY = y; mStart=getScrollY(); break; case MotionEvent.ACTION_MOVE: int dy = mLastY - y; if (!mScroller.isFinished()) { mScroller.abortAnimation(); } /* getScrollY()返回相对自己的初始位置的偏移量，计算方法为初始Y-nowY, * 当已经滑到顶端并且继续往下滑*/ if (getScrollY() &lt; 0 &amp;&amp; dy &lt; 0) { dy = 0; } //内容滑到底端且手指继续往上滑 if (getScrollY() &gt; (getHeight() - mScreenHeight) &amp;&amp; dy &gt; 0) { dy = 0; } scrollBy(0, dy); mLastY = y; break; case MotionEvent.ACTION_UP: //手指往上滑时，值为负；反之为正 int end=getScrollY(); int scrollY=end-mStart; //手指往上滑 if(scrollY&lt;0){ if((-scrollY)&gt;(mScreenHeight/8)){ mScroller.startScroll(0,getScrollY(),0,-mScreenHeight-scrollY); } else { mScroller.startScroll(0,getScrollY(),0,-scrollY); } } //手指往下滑 else { if(scrollY&gt;(mScreenHeight/8)){ mScroller.startScroll(0,getScrollY(),0,mScreenHeight-scrollY); } else { mScroller.startScroll(0,getScrollY(),0,-scrollY); } } break; } return true; } @Override public void computeScroll() { super.computeScroll(); if (mScroller.computeScrollOffset()) { scrollTo(0, mScroller.getCurrY()); postInvalidate(); } } } 一些小细节值得优化，大体效果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[view的绘制过程]]></title>
      <url>%2F2017%2F02%2F19%2FView%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[View和ViewGroup简介在安卓中，显示的视图可以分为两类，view和viewgroup，而view是所有控件的基类，viewgroup也是继承自view的，不同的是viewgroup可以容纳子view，而view不能再容纳任何子view。而我们平时在布局文件里使用的绝大多数控件，都是view类和viewgroup的子类。viewgroup的子类：各种layout布局，比如linerlayout，framelayout，relativelayout等等。view的子类：各种控件，比如textview，button等等。这样以来，布局文件里的内容就形成了一棵树状结构，即我们经常谈起的view树： 为了方便描述，下文用view指代控件（不能包含子view），用viewgroup指代容器（可以包含子view） View的显示过程view的显示必须经过测量、布局和绘制三个阶段，分别对应onMeasure()、onLayout()和onDraw()三个回调方法。作用分别如下：onMeasure()——经过测量初步确定view的宽和高（至于为什么是初步确定，后面再讲解）onLayout()———根据onMeasure()中初步确定的宽高，对view进行布局即确定当前的view应该放在屏幕的哪个位置，（这一步有可能对初步确定的宽和高重新赋值）onDraw()———调用绘图api(canvas.drawXX()方法)在该位置绘制view，至此，view便显示在屏幕上了 1.view的测量首先需要明确一点，所有子view的测量都是在直接父viewgroup的控制下完成的，什么意思？比如现在有如下布局文件：根布局linearlayout具有两个直接子view——framelayout和button，所以framelayout和button的测量是由linearlayout控制完成的，那么怎么控制并完成的呢？首先，viewgroup自身的measure()方法被调用，在进行一些处理之后，measure()方法内部调用onMeasure()方法，onMeasure()方法循环遍历自己的直接子view，并且调用每个子view的measure()方法（不是onMeasrue()），FrameLayout中该方法部分实现如下： if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); //获取子view在xml文件中设置的布局参数 final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //根据子view的布局参数确定子view的width，不进行合法性检查 final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } //根据子view的布局参数确定子view的height，不进行合法性检查 final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } //调用子view的measure()方法 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } 可以看到最终父viewgroup调用了每个直接子view的measure()方法，而为什么不是调用子view的onMeasure()方法呢？我理解的原因主要有两个： onMeasure()方法为protected类型，只能在子类内部访问，不能在外部访问。 measure()方法还会进行进一步的复杂处理，包括传入参数的优化等，执行这些代码之后，才会调用onMeasure()方法。 这是view.measure()方法中调用onMeasure()的部分： if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } 下面是View.onMeasure()的默认实现： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 通过 setMeasuredDimension方法设定该view的初步测量值。最内层的getSuggestedMinimumWidth()将返回父view能容纳的最大值。getDefaultSize方法用于返回默认的大小，实现如下： public static int getDefaultSize(int size, int measureSpec) { //将result赋值为父视图的最大值 int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { //未确定的时候赋值为size case MeasureSpec.UNSPECIFIED: result = size; break; //wrap_content的时候不进行赋值操作，即默认为size的大小 case MeasureSpec.AT_MOST: //指定为精确值 case MeasureSpec.EXACTLY: result = specSize; break; } return result; } 分析以上方法的执行可以得出结论，默认的View.onMeasure()方法不支持wrap_content属性，即使在xml中指定为wrap_content也会默认设置为充满父view所以，在自定义view的时候，要想你的view支持wrap_content属性，必须覆盖view的onMeasure()方法并加入wrap_content的相关逻辑。view.measure为final方法，不能覆盖 这样，view的测量阶段就完成了。 view的布局同view的测量类似，这一阶段viewgroup自身的layout()方法被调用，确定自己的位置之后，layout()方法内部调用onlayout()，onLayout()调用layoutChildren()方法来对所有直接子view进行布局，FrameLayout中的具体实现： protected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false ); } layoutChildren()方法的部分实现： void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { //获取直接子view数量 final int count = getChildCount(); 此处代码有省略... for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { //获取子view在xml布局文件中定义的属性 final LayoutParams lp = (LayoutParams) child.getLayoutParams(); 此处代码省略...（省略的代码主要用于各种判断逻辑，用来确定布局位置） //调用子view的layout方法 child.layout(childLeft, childTop, childLeft + width, childTop + height); } } } 可以看到和测量过程类似，都是通过循环取得每一个子view，再获得子view在xml文件中定义的各种属性，加以判断，最后调用子view的对应方法，不同的是，测量过程更关心view的宽和高，所以主要判断大小相关的属性。而布局过程更关心view的位置，所以判断的属性大都是view的位置相关属性，比如centerinparent是否为true等等。在view的layout()方法又会调用onLayout()方法： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //调用setframe或者setOpticalFrame方法来设置该自己相对于父viewgroup的坐标(左上和右下) boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { //调用子view的onLayout()方法 onLayout(changed, l, t, r, b); ... } View类的onLayout()方法默认实现为空： protected void onLayout(boolean changed, int left, int top, int right, int bottom) { } 再来总结一下layout阶段的工作： 父viewproup的layout方法被调用，首先调用setframe或者setOpticalFrame设置自己的位置，然后调用onLayout()方法循环遍历子view并调用子view.layout() 子view的layout()方法通过调用内部setframe或者setOpticalFrame方法来设置该view相对于父viewgroup的坐标 子view.layout()方法调用自己的onLayout()方法 由于view不能再包含子view，而且view的位置在view类内部的layout()方法中已经通过setframe或者setOpticalFrame确定，所以继承view类来自定义view的时候，一般不用覆盖onLayout()方法到此，view的位置也已经确定好了。 view的绘制这一阶段父viewproup调用子视图(可能是viewgroup也可能是view)的draw()方法，draw()方法在View类进行了实现，部分实现如下： public void draw(Canvas canvas) { ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ ... if (!verticalEdges &amp;&amp; !horizontalEdges) { // 绘制自己 if (!dirtyOpaque) onDraw(canvas); // 绘制子视图 dispatchDraw(canvas); ... } 可以看到draw()方法先调用自己的onDraw()方法绘制自己，然后调用 dispatchDraw(canvas)来遍历得到所有子视图（可能是viewgroup也可能是view）并调用子视图的draw()方法，draw()方法的关键实现已在上面代码中说明。可以看到 假如子视图是一个view，调用了子视图的onDraw()方法之后，dispantchDraw()虽然得到了调用，但是方法中不会再进行绘制子视图操作，因为view不可能在包含子视图。 假如子视图是viewgroup，若该viewgroup没有指定background属性，那么该viewgroup的OnDraw()方法不会被调用（由于if(!dirtyOpaque)），但是dispatchDraw()方法始终会被调用，因为viewgroup一般都包含有子视图。 至此，view的绘制过程也结束了，view最终成为了我们看到的样子。 view显示过程缩略概括 viewgroup和view的测量：首先，最外层viewgroup的measure()方法得到调用，measure()方法进行了一些处理之后，其内部又调用了onMeasure()方法，在onMeasure()方法中除了进行自身的测量并调用setMeasuredDimension()设置自身大小之外，若该视图下包括了子视图，还要遍历调用所有子视图的measure()方法。所以viewgroup的onMeasure()方法除了初步测量自身的大小，还要初步测量子view的大小，并调用子.view的measure()方法传入初步测量的高和宽，由子view的onMeasure()方法再次确定合适的大小 viewgroup和view的布局：最外层viewgroup的layout()被调用，该方法设置了自己的位置之后，调用自身onLayout()遍历所有子视图并调用子视图的layout()方法。ViewGroup类的onLayout()方法是抽象方法，自定义viewgroup时必须实现，而View类的onLayout()方法默认实现为空 viewgroup和view的绘制最外层viewgroup的draw()被调用，viewgroup若没有设置background属性则不会执行自己的onDraw(),继续执行dispatchDraw()遍历绘制所有子view。 拓展 既然measure、layout和draw都是从最外层viewgroup开始的，那么是谁调用了最外层viewgroup的measure()、layout()和draw()方法呢？答案是viewRoot的performTraversals()方法: private void performTraversals() { ............ //获得view宽高的测量规格，mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); // Ask host how big it wants to be //执行测量操作 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ........................ //执行布局操作 performLayout(lp, desiredWindowWidth, desiredWindowHeight); ....................... //执行绘制操作 performDraw(); } 这里给出一张安卓UI的架构图：至于Activity,Window,DecorView 和 ViewRoot 的关系和职责，可以参考以下链接：点我点我 view.getMeasuredWidth()和view.getWidth()的区别view.getMeasuredWidth()——获得在onMeasure()方法中调用setMeasuredDimension()之后的view宽度,执行setMeasuredDimension()之后mMeasuredWidth才被赋值，进而onLayout阶段可以调用getMeasuredWidth()获得初步测量的宽度 view.getWidth()——获得在onLayout()方法之后的view宽度在重写了onLayout方法之后，二者的返回值视重写的逻辑而定有可能不同，比如某个view在xml中指定宽度为1000dp,那么测量阶段的值就是1000dp，而假如你在layout()里加入判断认为该值过大，然后在该方法中向的setframe()传递了一个新的宽度值，getWidth()方法就将返回该值，这只是举的特殊情况，大多数情况下二者还是一样的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio修改Gradle版本]]></title>
      <url>%2F2017%2F02%2F01%2FAndroid-Studio%E4%BF%AE%E6%94%B9Gradle%E7%89%88%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[最近重新下载安装了AS，发现对gradle的配置有些忘记了，写下这篇博客做个记录。 相关介绍下载的android studio分为自带SDK（.exe）和不带SDK（.zip）两种版本，如下图所示：自带sdk版本安装之后会让你选择sdk的安装位置，而不带sdk版本解压之后第一次运行会下载sdk，默认位置为C:\Users\username\AppData\Local\Android\sdk，在AS里可以修改其位置。至于gradle，AS里是自带一个版本的gradle的(具体版本视AS版本而定)，如图:如果以前没有修改过的话，在C:\Users\username.gradle下也有gradle，内容如下：，两者的区别在后面进行讲解。 AS的gradle路径指定在AS里选择file-&gt;settings-&gt;搜索gradle：在这里可指定gradle路径。use default gradle wrapper————使用global gradle settings路径所指定的的gradle。use local gradle distribution————使用gradle home中指定的gradle(与global中指定的目录无关)。两者都是正确的配置方法，但是对应的gradle目录有所不同。就我而言，wrapper方式的gradle目录路径为：D:\android\gradle\wrapper\dists\gradle-2.14.1-all\8bnwg5hd3w55iofp58khbp6yv\gradle-2.14.1而选择local distribution的路径为：D:\android\android-studio\gradle\gradle-3.2可以看到前者的目录路径中多了wrapper等目录，这是由AS生成的。 修改gradle版本如果在AS内自动下载gradle的话可能比较慢，这时需要自己下载gradle的各个版本进行版本修改。gradle各版本下载地址修改的方式有两种： 将下载的gradle压缩包解压到某个目录，在AS里选择use local distribution，并将路径指定为该目录。 将gradle压缩包放在wrapper\dists\gradle-2.14.1-all\8bnwg5hd3w55iofp58khbp6yv\目录下(路径中的一长串字母是AS生成，各有不同)，在AS中指定use default gradle wrapper,并指定global gradle setting路径为wrapper目录的上一级目录，最后sync gradle就完成了，当然你可以放置多个版本的gradle压缩包来安装多个版本的gradle，在项目sync的时候会自动搜寻匹配的版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toolbar+tablayout分割线处理]]></title>
      <url>%2F2017%2F01%2F26%2Ftoolbar-tablayout%E5%88%86%E5%89%B2%E7%BA%BF%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[有一段时间没有更博了，期末考试结束之后学习到的基本都是零散的小知识，总觉得没什么必要写在博客里，不过现在看来，有些东西不记录的确很快就会忘记。在这里记录一下最近使用tablayout+toolbar+drawerlayout中遇到的问题。tablayout的基本使用可以参考这篇文章tablayout的基本使用drawerlayout的使用可以参考如下文章drawerlayout简单使用 问题描述下面是我遇到的问题，项目的开始，按照google的guide，我实现的tablayout+toolbar+drawerlayout界面，这是一个比较简单的界面当进行向上滑动的时候toolbar将进行隐藏，但是可以明显的看到，toolbar与tab之间有一条横线，很不协调。一开始我认为是toolbar的elevation属性导致了该原因，将该属性去掉之后问题仍然不能解决。网上也有资料说将tablayout放置在toolbar中(因为toolbar继承自viewgroup，也是一个容器)，但是在我的app中，同时用到了drawerlayout，你可能想在每个fragment中include一个toolbar，再将tablayout放在toolbar中，当然如果你的toolbar只是用来显示一个标题的话，完全可以这样做，但是因为toolbar中还包括了一个drawertoggle，如果这样就需要将每个toolbar与drawerlayout和toggle进行绑定，显得比较麻烦，所以我只采用了一个toolbar+framelayout(用于放置抽屉item对应的fragment)。 解决方法由于toolbar是包裹在appbarlayout中的，设置该appbarlayout的app:elevation=0，就能解决问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mvp学习笔记]]></title>
      <url>%2F2016%2F12%2F17%2Fmvp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[前言为了保证每周的学到了一些东西，我尽量坚持每周更新一篇博客，最近临近期末开始方了。这篇博客就作为我学习安卓mvp架构的一个记录，至于什么是mvp以及关于mvp的详细介绍，网上的博客真的是太多太多了，这里给出一个我觉得不错的链接来自鸿洋大神，致敬浅谈mvp in Android 我对mvp的理解 mvp运用的主要就是java中的接口(interface)来进行代码的解耦，使得代码可读性更高，维护起来更加方便，最重要的是实现了数据的获取和数据显示二者之间的独立。下面是在学习mvp架构之后的一些总结： view层——只负责数据的显示，presenter层传回什么数据就显示什么数据，并将用户的输入传入presenter层。 presenter层——负责连接view层和model层，presenter层对来自view层的用户输入进行合法性检查（比如检查一个editText的输入内容是否为空）并将输入传输到model层；presenter层在获得model层返回数据之后调用view层实现数据的显示。 model层——实现数据的获取、处理（可以是从内存、磁盘、和网络获取数据）并返回给presenter层。 所以典型的mvp架构工作过程可以如下表示： view获取用户输入并传入presenter presenter进行合法性检测，合法就传入model model以presenter传入的数据作为参数进行数据操作 model将操作的结果返回给presenter presenter调用view进行数据显示 简单demo根据上述mvp，个人实现的简单demo，demo只有功能木有UI，为了后续的开发做准备，实现查询历史上的今天（返回数据未处理）基础接口：view和presenter(官方demo将二者放在了contract接口中)： public interface QueryContract { interface iView extends BaseView&lt;iPresenter&gt; { void showEmptyInputError(); void showLoading(); String getMonth(); String getDay(); void initViews(); void dismissLoading(); void showResult(String response); } interface iPresenter extends BasePresenter{ void loadToday(String month, String day); } } model(onQueryListener接口用于model查询结果回调)： public interface iModel { void queryTodayInHistory(String url,onQueryListener listener); interface onQueryListener{ void onSuccess(String result); void onFail(); } } 接口实现类presenter: public class PresenterImp implements QueryContract.iPresenter{ private QueryContract.iView mView; private iModel mModel; PresenterImp(QueryContract.iView view) { this.mView=view; this.mModel=new modelImp(); } @Override public void loadToday(String month, String day) { if(!isEmpty(month,day)){ String TODAYURL = &quot;http://v.juhe.cn/todayOnhistory/queryEvent.php&quot;; String APPKEY = &quot;664905c187ef805a534bb457bb5b3b9f&quot;; String QUERYURL= TODAYURL +&quot;?date=&quot;+month+&quot;/&quot;+day+&quot;&amp;key=&quot;+ APPKEY; mView.showLoading(); mModel.queryTodayInHistory(QUERYURL, new iModel.onQueryListener() { @Override public void onSuccess(String result) { mView.showResult(result); } @Override public void onFail() { } }); } else { mView.showEmptyInputError(); } } private boolean isEmpty(String month, String day) { return month.equals(&quot;&quot;) || day.equals(&quot;&quot;); } @Override public void start() { } } model(查询历史上的今天): public class modelImp implements iModel { @Override public void queryTodayInHistory(final String url, final onQueryListener listener) { //query today with okHttp new Thread(new Runnable() { @Override public void run() { Response response; String result=&quot;&quot;; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url(url) .build(); try { response=client.newCall(request).execute(); result= response.body().string(); if(result.contains(&quot;success&quot;)){ listener.onSuccess(result); } else { listener.onFail(); } } catch (IOException e) { e.printStackTrace(); } } }).start(); } } view实现比较简单，主要负责显示数据，但是必须保证工作在UI线程，例如： @Override public void showResult(final String response) { runOnUiThread(new Runnable() { @Override public void run() { tvResponse.setText(response); } }); } mvp需要注意的地方mvp中的网络操作部分主要由model来完成，很多情况下model（操作运行在子线程）在获取到网络的数据之后需要对其进行解析（如将json格式的字符串解析为javabean）并返回给presenter，presenter负责通知view更新UI，但是UI。在这个操作中有几个需要注意的地方： 从model的子线程返回数据时，不能采用在model的子线程中对成员变量进行赋值，然后在主线程中来访问该成员变量的方法，因为大多数情况下，当在主线程中访问该成员变量的时候，子线程尚未执行完毕，此时变量没有值，将会得到nullpointer异常。 在设计model中涉及网络操作的方法时，尽量将返回值设置为void而不设置为需要返回的javabean类型，因为presenter调用方法发生在主线程，而方法中的代码执行在子线程，会导致子线程还没有执行完毕，该方法就已经返回，也会得到nullpointer异常。正确的解决方法是，采用回调的方式（即为model中的方法传入一个接口用于回调），当model中获得数据之后回调接口中的方法来通知presenter，进而在UI线程更新UI view中更新UI必须保证运行在UI线程，android提供了如下几种方法来保证代码运行在UI线程： 此外还包括handler以及asyncTask 运行效果其实木有什么效果可言，使用“万能Activity”同样可以实现，不过既然是练习mvp，总还是要给出一点实际的东西吧哈哈，效果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射学习笔记]]></title>
      <url>%2F2016%2F12%2F06%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[前言最近学年设计地图app遇到了一个小的需求，那就是地图的POI搜索功能，当用户点击搜索的时候，会弹出一个dialog让用户进行输入，但是当输入的内容为空的时候，必须提醒用户让用户重新输入，但是现在有个问题，就是Android中利用AlertDialog.builder创建的dialog不管你是点击任何按钮或者点击屏幕dialog的外部，对话框都会无条件退出，那么怎么让我的dialog在用户不合法操作的时候不退出呢？那就可以用到反射机制。 什么是反射？ 反射(reflection)是java里面的一种机制，它允许你在程序运行的时候获取类的信息（通过class对象），什么是类的类型信息呢？假如有个类A{}，那么A类的类型信息可以简单地理解为： A类中定义了哪些成员属性 A类中定义了哪些成员方法 A类中定义了哪些构造方法 反射允许我们在运行的时候获得类的所有上述信息来进行操作，这些操作可以是在运行时修改某个对象的私有属性，调用对象的私有方法，和调用对象的构造方法创建新的对象。这样说你可能还是不容易理解，请继续往下看。 反射的基石——Class对象Class对象又是什么鬼？ 首先刚才在上面说到了，反射机制可以允许我们在运行时获得某个类的信息，那么我们怎么来表示这个类的信息呢？或者说，我们这个类的信息是封装在什么地方的呢？答案就是Class对象，每个类都对应了一个Class对象，你可以简单地理解为：每个类都对应了自己唯一的Class对象，而这个Class对象包含了关于这个类的全部信息（有哪些属性，哪些方法）。 首先，你必须清楚，在java这个面向对象的世界里，一切都是对象，一切都是对象，一切都是对象~我们的类也是对象（Class类的对象），类的成员方法也是对象（Method类的对象），构造方法是Constructor类的对象，类的属性也是对象（Field类的对象）。也就是说我们平时写java程序的时候，不管你是使用API里的类还是自己写的类，他们都是Class类的对象。 现在我们来理解java的类是在运行时期动态加载的这句话的意思，也就是说，java程序在运行的时候不会把所有的类全部加载到jvm中去，而是在你需要的时候再通过类加载器加载到jvm中去的，那么什么时候才是需要这个类的时候呢？最常见的就是当你调用这个类的构造方法的时候，jvm会加载该类的字节码（.class文件）到jvm，而在加载该类的过程中，就会由jvm产生一个该类的Class对象。这个对象代表了这个类的所有信息，是这个类在运行时期的唯一标识。 这里谈到了jvm的类加载过程，到现在为止我只是简单地浏览了一遍，可能上面的步骤说的不是很详细，在这里推荐一本书——《Java虚拟机精讲》-高祥龙著，将的挺好的，适合想要初步了解JVM的人群。 怎么获取Class对象？既然Class对象是jvm在加载类的时候创建的，它又封装了类的详细信息，那么怎么获得某个类的Class对象呢？ Class对象的获取和普通对象有所区别，不能通过Class a=new Class()这种方式，java不允许我们自行创建Class对象的实例，它是由jvm自动创建，而我们只能通过以下三种方式获取到Class对象： Class.forname(classname) obj.getclass() classname.class 下面通过一个例子来一一解释以上三种方式，假如现在要获取String类的Class对象： 第一种：Class.forname()这是通过Class类的静态方法forname方法获取Class对象，形参classname形式必须为包名+类名。那么我们通过这种方式获取A的Class对象的方式为：Class.forname(Java.lang.String)。 第二种：obj.getclass()当你已经拥有了一个该类的对象的时候，就可以调用obj.getclass()方法来获取Class对象，比如已经得到String类的对象A，就可以执行A.getclass()来获取String类的Class对象（getclass（）方法为Object类的成员方法）。 第三种：classname.classclassname.class又叫做类字面常量。这种方式获取String类的Class对象就为String.class。 classname.class方式和Class.forname()方式的区别 Class.forname()方式，倘若在执行该方法的时候该类并没有被加载，则会启动类加载器对类进行加载；而classname.class方式不会导致该类的加载。（来自java编程思想第四版），二者都会导致类的加载，但是Class.forname()会进行类的初始化（在类加载的连接阶段执行类的静态代码块和静态成员的初始化），但是classname.class不会导致该步骤的执行，这种方式直到第一次引用类的静态成员或者调用静态方法的时候才会执行类的初始化。 获取到了Class对象之后我可以做什么？获取到了类的Class对象，你就相当于获取了这个类的很多信息，可以调用Class对象的getMethods()方法获取到该类的所有方法（包括从父类继承的方法），也可以调用getConstructor()方法获取该类的所有构造方法，还可以调用getField()方法获得该类的全部成员属性（包括私有属性） 比如我们可以通过以下简单代码在运行时获取String类的信息： public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; stringInfo= Class.forName(&quot;java.lang.String&quot;); for (Method method : stringInfo.getMethods()) { System.out.println(method); } for (Field field : stringInfo.getFields()) { System.out.println(field); } for (Constructor&lt;?&gt; constructor : stringInfo.getConstructors()) { System.out.println(constructor); } } 上面的代码简单地获取了String类的所有方法和属性，运行的截图如下： 这只是Class对象的最简单使用，但是还没牵扯到反射机制的使用，Class对象的更详细方法以及使用请参考java官方在线文档 通过Class对象使用反射机制在得到类的Class对象之后，我们可以进行的操作还远远不止上面的那些操作，还可以通过该对象得到特定的方法引用并且把它赋值给Method类型的引用（因为任何一个方法都是Method类的实例），然后通过调用Method类的invoke()方法，同样可以达到调用对应的成员方法的效果，那么下面我们通过反射机制来调用String类的方法： public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { String aString=&quot;hello world&quot;; Class&lt;?&gt; stringInfo= aString.getClass(); try { Method refectMethod=stringInfo.getDeclaredMethod(&quot;toUpperCase&quot;); String bString=(String) reflectMethod.invoke(aString); System.out.println(bString); } catch (NoSuchMethodException | SecurityException e) { // TODO Auto-generated catch block e.printStackTrace(); } 同样很简单，首先获得String类的Class对象，然后通过该对象获得toUpperCase方法，此时refectMethod()就代表了String类的toUpperCase(),再调用Method的invoke()方法，该方法的原型声明为：public Object invoke(Object obj, Object… args)，形参分别表示需要操作的对象，以及方法的参数，由于toUpperCase()方法本身不带参数，所以调用invoke()只需传入操作的对象aString即可。 运行效果：上述就是一个极为简单的例子，但是反射的运用肯定还远不止这些，共勉。 安卓dialog退出过程分析既然点击了按钮就会导致dialog消失，那么我们就来看看在AlertDialog源码中按钮点击之后都发生了什么：按钮监听事件是在builder的setPossitiveButton()中设置的，那么来到builder的源码，会发现该方法的实现：这里完成的就是对p.mPositiveButtonListener的赋值，也就是只要你为按钮设置了监听器，那么这个值就肯定被赋值为你的监听器了，这个时候发现源代码中有一个p,在AS中右键查看源码，p为AlertController.AlertParams类型，进入该类的源码(AlertParams是一个静态内部类)，发现在apply()方法中有如下代码（只截取了该方法源码的一部分），该方法在调用builder.create()的时候会被调用： public void apply(AlertController dialog) { if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } } 可以看到在apply()方法中调用dialog的setButton()方法设置了按钮的参数（分别对应setButton方法的四个参数），setButton()方法是AlertParams类所在的外部类AlertController中的方法，实现如下： public void setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener, Message msg) { if (msg == null &amp;&amp; listener != null) { msg = mHandler.obtainMessage(whichButton, listener); } switch (whichButton) { case DialogInterface.BUTTON_POSITIVE: mButtonPositiveText = text; mButtonPositiveMessage = msg; break; case DialogInterface.BUTTON_NEGATIVE: mButtonNegativeText = text; mButtonNegativeMessage = msg; break; case DialogInterface.BUTTON_NEUTRAL: mButtonNeutralText = text; mButtonNeutralMessage = msg; break; default: throw new IllegalArgumentException(&quot;Button does not exist&quot;); } } 在该方法中对各个按钮进行了设置，apply()方法传入的message参数为null，该message对象在本方法中进行了赋值(if语句中)，赋值之后的message对象封装了我们最开始设置的监听器对象，用于接下来在按钮点击之后执行 接下来看点击事件的监听器源码（其中会调用到我们自己的监听器）： private final View.OnClickListener mButtonHandler = new View.OnClickListener() { @Override public void onClick(View v) { final Message m; if (v == mButtonPositive &amp;&amp; mButtonPositiveMessage != null) { m = Message.obtain(mButtonPositiveMessage); } else if (v == mButtonNegative &amp;&amp; mButtonNegativeMessage != null) { m = Message.obtain(mButtonNegativeMessage); } else if (v == mButtonNeutral &amp;&amp; mButtonNeutralMessage != null) { m = Message.obtain(mButtonNeutralMessage); } else { m = null; } if (m != null) { m.sendToTarget(); } // Post a message so we dismiss after the above handlers are executed mHandler.obtainMessage(ButtonHandler.MSG_DISMISS_DIALOG, mDialog) .sendToTarget(); } }; 各个按钮的点击事件已经在setButtons()方法中注册，从以上代码发现，在dialog中的按钮点击之后，首先会判断点击的按钮时哪一个，然后获取到对应的message对象，调用m.sendToTarget()通过异步的方式通知Handler的handleMessage方法执行我们最开始设置的监听器中的onClick()方法。 重点来了在执行m.sendToTarget()的下面还有两行代码，通过发送MSG_DISMISS_DIALOG消息，在Handler的handleMessage()方法中调用dismiss()方法退出dialog，这就是为什么点击按钮之后对话框无条件退出的原因。源码中handleMessage()方法的实现如下： private static final class ButtonHandler extends Handler { // Button clicks have Message.what as the BUTTON{1,2,3} constant private static final int MSG_DISMISS_DIALOG = 1; private WeakReference&lt;DialogInterface&gt; mDialog; public ButtonHandler(DialogInterface dialog) { mDialog = new WeakReference&lt;&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DialogInterface.BUTTON_POSITIVE: case DialogInterface.BUTTON_NEGATIVE: case DialogInterface.BUTTON_NEUTRAL: ((DialogInterface.OnClickListener) msg.obj).onClick(mDialog.get(), msg.what); break; case MSG_DISMISS_DIALOG: ((DialogInterface) msg.obj).dismiss(); } } } 可以看到最后一行调用了dismiss()方法退出对话框，跟踪到dismiss()方法你会发现内部是通过调用dismissDialog()方法退出对话框的，该方法实现代码： void dismissDialog() { if (mDecor == null || !mShowing) { return; } if (mWindow.isDestroyed()) { Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog&apos;s window was already destroyed!&quot;); return; } try { mWindowManager.removeViewImmediate(mDecor); } finally { if (mActionMode != null) { mActionMode.finish(); } mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); } } 在第一个if语句里判断了mShowing的值，这里的mDecor在Dialog类前面已经赋值过了（你可以查看源码），所以关键就在mShowing的值，当对话框已经显示其值就为true，但是如果设置mShowing为false，该方法就会马上return，也就不会执行后续的销毁对话框的代码，但是跟踪mShowing发现它是私有私有私有成员属性，那么怎么在运行时设置一个对象中私有属性的值呢？yeah，反射，反射，反射机制！ 前面说的比较冗长，简单地说，对话框消失的过程可以这样理解，在我们创建dialog的时候一般会调用setPositiveButton()方法传入我们自己的监听器，然后在create()(show会首先执行create)的时候该监听器会被赋值给dialog内部AlertParams对象的mPositiveButtonListener属性，然后该对象的apply()方法将该赋值后的mPositiveButtonListener封装在一个message对象中，在按钮被点击之后，就会获取我们先前message对象中封装的监听器，进而调用该监听器的onClick()方法执行我们在setPositiveButton()中传入的监听器逻辑，同时发送消息调用dismiss()方法让对话框消失。 阻止对话框退出既然原理都已经知道了，那就直接运行时判断，用户输入有误的话就通过反射修改mShowing的值为false，再手动调用dismiss(),由于mShowing为false，对话框就不会消失,代码如下： public void onClick(DialogInterface dialog, int which) { Field field = null; try { field = dialog.getClass().getSuperclass().getSuperclass().getDeclaredField(&quot;mShowing&quot;); field.setAccessible(true); } catch (NoSuchFieldException e) { e.printStackTrace(); } if (mEditText.getText().toString().equals(&quot;&quot;)) { try { field.set(dialog, false); dialog.dismiss(); mTextInputLayout.setError(&quot;亲，还没输入噢0.0&quot;); } catch (Exception e) { e.printStackTrace(); } } 运行效果：可以看到点击搜索按钮并没有退出对话框。 参考资料 CSDN博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github博客域名绑定]]></title>
      <url>%2F2016%2F11%2F30%2Fgithub%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[Hexo博客搭建、部署本文基于已经搭建完成hexo博客并且部署到github page，如果还没完成以上步骤请参考这里： hexo搭建博客并部署到github hexo官网传送门 ps：git和node.js需要翻墙，国内镜像： 淘宝node.js镜像 git国内镜像下载 阿里云域名绑定 github page默认的域名只能是yourgithubname.github.io，你可以部署属于自己的域名来方便记忆 (好吧我承认是感觉这个域名的确有点low)绑定个人域名，please continue to read. 1.购买阿里云域名我相信经常网购的你能在极短时间内购买到阿里云的域名，阿里云域名购买传送门，购买之前需要进行账号注册，注册成功之后在搜索框里输入你想购买的域名： 如果已经被注册你必须换一个域名，接下来一路点击购买就可以了，最后一步是到支付宝结账，bingo。 2.配置github仓库购买域名成功之后，你需要将该域名与你的博客域名相关联。 在自己本地的博客source文件夹下新建CNAME文件并填写域名（你的阿里云域名，不用加和http//：www.），然后hexo g -d部署到github。提一下自己填过的坑，以前是直接在github仓库”setting”的custom donains中设置为自己的阿里云域名，但是每次hexo g -d 重新部署之后就会导致博客404，原因是每次同步之后会导致远程仓库与本地同步，而我本地并没有CNAME文件，导致远程仓库删除CNAME文件，所以CNAME域名配置失效，博客404 现在依然是不能通过你的域名访问你的博客的，因为虽然有了域名，但是DNS还无法从你的域名解析到你的博客域名，接下来配置域名解析。 3.为你的域名添加域名解析登陆阿里云官网–&gt;点击左上角控制台–&gt;点击左侧DNS云解析–&gt;添加解析。 参数解释： 记录类型： 分为A记录解析和CNAME记录解析，A记录解析是指将 域名 解析到具体的 ip 地址上去；CNAME解析是指将一个 域名 解析到另一个 域名 上去。 主机记录：若填写www，意味着现在我们是在配置www.yourdomain的域名解析，@表示空值 记录值：当选择A记录解析，指代将要解析到的目的ip地址；当选择CNAME记录解析，指代将要解析到的目的域名。 TTL：生存时间值(time to live),可以这样理解：假如你在浏览器输入了abc.com这个域名，此时浏览器向DNS服务器A查询abc.com对应的ip是多少，很遗憾，你附近的DNS服务器没有abc.com对应的ip记录，那么它将递归向比它更高级DNS服务器B进行查询，查询成功之后会讲结果ip返回给你，它自己也会增加一条abc.com到ip地址的映射记录，而这条记录可以在A上保存的时间，就是TTL的值。 因为我们是要将你的阿里云域名解析到你的github博客，选择A记录（至于为什么不采用CNAME解析，下文会讲到），主机记录填@或者不填（不填默认为@），记录值为github服务器ip（可以是这两种的任意一种(图片来自官方文档截图)： ps：很多教程说上面的ip填写你的github博客域名ping yourname.github.io的结果ip，本人试过也的确可以，但是推荐按照官方的方法。 4.大功告成在浏览器里输入你的域名，就可以访问到你的博客啦~~~ 你或许想问1.我在阿里云的域名解析中已经添加了我的CNAME域名解析，为什么还要在我的github page仓库里新建CNAME文件？ 我的理解：CNAME文件用来保存你的自定义域名，你可以这样理解，github的服务器上要存放那么多的博客文件，而每一个博客文件不可能存放在单独的服务器上，那样代价太大，所以我们的博客应该是存放在同一个服务器上的（就是上面A记录中的ip地址对应的服务器），而服务器正是通过每个博客文件中的CNAME文件来区分不同用户的博客。举个例子：我的CNAME文件内容为www.distancelin.cn，那么当我在浏览器输入这个域名的时候，根据我配置的A记录，找到了github的服务器，那么服务器就会准确匹配到我的博客文件来返回给我的浏览器，由浏览器解析显示，而这个匹配过程正是CNAME文件的内容决定的（因为文件内容就是我的域名www.distancelin.cn） 官方也明确说明必须新建CNAME文件用于page重定向。github page 中文文档 2.CNAME文件内容到底加不加www？ 身为强迫症患者的我，最终弄懂了这个问题，当你的域名解析同时配置了顶级域名的A记录和www域名的记录的时候，比如我的：这个时候github服务器会根据你的CNAME文件内容进行域名的重定向： 当你的CNAME文件内容不含www，服务器会将www.XXXXX重定向到XXXXX 当你的CNAME文件内容包含www，服务器会将XXXXX重定向到www.XXXXX 你可以简单地这样理解，CNAME文件是否包含www决定了在同时配置了顶级域名和www域名的情况下，浏览博客时网址栏是否包含www.官方推荐使用子域名，链接，而网上也有说用顶级域名更容易被搜索引擎收录，所以，带不带www，it’s up to you. 3.我是要配置A记录还是CNAME记录？ 如果你的CNAME文件内容加了www,那么就直接配置CNAME记录就可以了，在你的阿里云域名解析中添加一项CNAME记录解析，主机记录填www,记录值填写你的github page域名，比如我的就是distancelin.github.io，这样比如我的博客就可以通过www.distance.cn来访问。 如果你的CNAME文件内容没有加www，那么就配置A记录吧，主机记录不填，记录值填github官方服务器ip，前面截图中给出的两个ip，现在我的博客就可以通过distancelin.cn访问了。ps：聪明的你可能会思考，为什么我不直接对顶级域名添加CNAME解析直接解析到我的github page 博客呢？我一开始就是这样干的，也成功了，但是官方强烈建议不要对你的顶级域名进行CNAME解析，因为可能导致其他服务在顶级域名上的冲突，官方原话传送门 4.怎样让我的博客在加或者不加www的基础上都能访问？ 保证DNS解析中存在以下两条解析：1.记录类型A、主机记录@（空）、记录值github服务器ip2.记录类型CNAME、主机记录www、记录值你的github博客域名 补充到此github page 和自定义域名的绑定就算记录完了，除此之外，如果你觉得github服务器在国外访问起来慢的话可以在coding.net上同时部署你的博客，但是据说coding的ip经常变化，不容易配置顶级域名的A记录,而CNAME记录最好是不要配置在顶级域名上，博主只配置了coding的www子域名，如果你有更好地解决办法，请在评论中给我留言，感激不尽。 参考资料极客学院wiki团队github page指南杨宽同学的博客 写在最后按照教程来做其实不用花费这么多时间的，但我在一些细节上感觉很纠结，折腾了这么久终于思路清晰了。这篇博客是博主的第一篇博客，也是在摸爬滚打了半年的Android开发之后一个新的开始，从markdownpad的使用到博客语言组织方式上都还有很大不足，发现错误还请赐教，thanks！]]></content>
    </entry>

    
  
  
</search>
